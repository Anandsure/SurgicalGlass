# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_speech_py_impl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_speech_py_impl')
    _speech_py_impl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_speech_py_impl', [dirname(__file__)])
        except ImportError:
            import _speech_py_impl
            return _speech_py_impl
        try:
            _mod = imp.load_module('_speech_py_impl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _speech_py_impl = swig_import_helper()
    del swig_import_helper
else:
    import _speech_py_impl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x



from typing import Optional



DocstringForPropertyId = """
   Defines speech property ids.

   *Values:*

    .. py:attribute:: SpeechServiceConnection_Key

      The Cognitive Services Speech Service subscription key. If you are using
      an intent recognizer, you need to specify the LUIS endpoint key for your
      particular LUIS app. Under normal circumstances, you shouldn't have to
      use this property directly. Instead, construct a
      :py:class:`.SpeechConfig` instance from a subscription key.

    .. py:attribute:: SpeechServiceConnection_Endpoint

      The Cognitive Services Speech Service endpoint (url). Under normal
      circumstances, you shouldn't have to use this property directly. Instead,
      construct a :py:class:`.SpeechConfig` instance from a subscription key.

      .. note::

        This endpoint is not the same as the endpoint used to obtain an access token.

    .. py:attribute:: SpeechServiceConnection_Region

      The Cognitive Services Speech Service region. Under normal circumstances,
      you shouldn't have to use this property directly. Instead, construct a
      :py:class:`.SpeechConfig` instance from a subscription key, an endpoint, a host,
      or an authorization token.

    .. py:attribute:: SpeechServiceAuthorization_Token

      The Cognitive Services Speech Service authorization token (aka access
      token). Under normal circumstances, you shouldn't have to use this
      property directly. Instead, construct a :py:class:`.SpeechConfig`
      instance from an authorization token, or set
      :py:obj:`.Recognizer.authorization_token`.

    .. py:attribute:: SpeechServiceAuthorization_Type

      The Cognitive Services Speech Service authorization type. Currently
      unused.

    .. py:attribute:: SpeechServiceConnection_EndpointId

      The Cognitive Services Custom Speech Service endpoint id. Under normal
      circumstances, you shouldn't have to use this property directly. Instead
      set :py:obj:`.SpeechConfig.endpoint_id`.

      .. note::

        The endpoint id is available in the Custom Speech Portal, listed under
        Endpoint Details.

    .. py:attribute:: SpeechServiceConnection_Host

      The Cognitive Services Speech Service host (url). Under normal
      circumstances, you shouldn't have to use this property directly. Instead,
      construct a :py:class:`.SpeechConfig` instance.

    .. py:attribute:: SpeechServiceConnection_ProxyHostName

      The host name of the proxy server used to connect to the Cognitive
      Services Speech Service. Under normal circumstances, you shouldn't have
      to use this property directly. Instead, use
      :py:meth:`.SpeechConfig.set_proxy`.

    .. py:attribute:: SpeechServiceConnection_ProxyPort

      The port of the proxy server used to connect to the Cognitive Services
      Speech Service. Under normal circumstances, you shouldn't have to use
      this property directly. Instead, use :py:meth:`.SpeechConfig.set_proxy`.

    .. py:attribute:: SpeechServiceConnection_ProxyUserName

      The user name of the proxy server used to connect to the Cognitive
      Services Speech Service. Under normal circumstances, you shouldn't have
      to use this property directly. Instead, use
      :py:meth:`.SpeechConfig.set_proxy`.

    .. py:attribute:: SpeechServiceConnection_ProxyPassword

      The password of the proxy server used to connect to the Cognitive
      Services Speech Service. Under normal circumstances, you shouldn't have
      to use this property directly. Instead, use
      :py:meth:`.SpeechConfig.set_proxy`.

    .. py:attribute:: SpeechServiceConnection_Url

      The URL string built from speech configuration. This property is intended
      to be read-only. The SDK is using it internally.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceConnection_TranslationToLanguages

      The list of comma separated languages used as target translation
      languages. Under normal circumstances, you shouldn't have to use this
      property directly. Instead use
      :py:meth:`.SpeechTranslationConfig.add_target_language` and
      :py:obj:`.SpeechTranslationConfig.target_languages`.

    .. py:attribute:: SpeechServiceConnection_TranslationVoice

      The name of the Cognitive Service Text to Speech Service voice. Under
      normal circumstances, you shouldn't have to use this property directly.
      Instead set :py:obj:`.SpeechTranslationConfig.voice_name`.

      .. note::

        Valid voice names can be found `here <https://aka.ms/csspeech/voicenames>`_.

    .. py:attribute:: SpeechServiceConnection_TranslationFeatures

      Translation features. For internal use.

    .. py:attribute:: SpeechServiceConnection_IntentRegion

      The Language Understanding Service region. Under normal circumstances,
      you shouldn't have to use this property directly. Instead use
      :py:class:`.LanguageUnderstandingModel`.

    .. py:attribute:: SpeechServiceConnection_RecoMode

      The Cognitive Services Speech Service recognition mode. Can be
      "INTERACTIVE", "CONVERSATION", "DICTATION". This property is intended to
      be read-only. The SDK is using it internally.

    .. py:attribute:: SpeechServiceConnection_RecoLanguage

      The spoken language to be recognized (in BCP-47 format). Under normal
      circumstances, you shouldn't have to use this property directly. Instead,
      use :py:obj:`.SpeechConfig.speech_recognition_language`.

    .. py:attribute:: Speech_SessionId

      The session id. This id is a universally unique identifier (aka UUID)
      representing a specific binding of an audio input stream and the
      underlying speech recognition instance to which it is bound. Under normal
      circumstances, you shouldn't have to use this property directly. Instead
      use :py:obj:`.SessionEventArgs.session_id`.

    .. py:attribute:: SpeechServiceConnection_SynthLanguage

      The spoken language to be synthesized (e.g. en-US)

      .. note::
        This property id was added in version 1.7.0.

    .. py:attribute:: SpeechServiceConnection_SynthVoice

      The name of the TTS voice to be used for speech synthesis

      .. note::
        This property id was added in version 1.7.0.

    .. py:attribute:: SpeechServiceConnection_SynthOutputFormat

      The string to specify TTS output audio format

      .. note::
        This property id was added in version 1.7.0.

    .. py:attribute:: SpeechServiceConnection_InitialSilenceTimeoutMs

      The initial silence timeout value (in milliseconds) used by the service.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceConnection_EndSilenceTimeoutMs

      The end silence timeout value (in milliseconds) used by the service.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceConnection_EnableAudioLogging

      A boolean value specifying whether audio logging is enabled in the service or not.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_RequestDetailedResultTrueFalse

      The requested Cognitive Services Speech Service response output format
      (simple or detailed). Under normal circumstances, you shouldn't have to
      use this property directly. Instead use
      :py:obj:`.SpeechConfig.output_format`.

    .. py:attribute:: SpeechServiceResponse_RequestProfanityFilterTrueFalse

      The requested Cognitive Services Speech Service response output profanity
      level. Currently unused.

    .. py:attribute:: SpeechServiceResponse_ProfanityOption

      The requested Cognitive Services Speech Service response output profanity
      setting. Allowed values are "masked", "removed", and "raw".

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_PostProcessingOption

      A string value specifying which post processing option should be used by
      service.  Allowed values are "TrueText".

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_RequestWordLevelTimestamps

      A boolean value specifying whether to include word-level timestamps in the
      response result.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_StablePartialResultThreshold

      The number of times a word has to be in partial results to be returned.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_OutputFormatOption

      A string value specifying the output format option in the response result.
      Internal use only.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_OutputFormatOption

      A boolean value to request for stabilizing translation partial results by omitting words in the end.

      .. note::
        This property id was added in version 1.5.0.

    .. py:attribute:: SpeechServiceResponse_JsonResult

      The Cognitive Services Speech Service response output (in JSON format).
      This property is available as :py:obj:`.RecognitionResult.json`.

    .. py:attribute:: SpeechServiceResponse_JsonErrorDetails

      The Cognitive Services Speech Service error details (in JSON format).
      Under normal circumstances, you shouldn't have to use this property
      directly. This property is available as
      :py:obj:`.RecognitionResult.error_json`.

    .. py:attribute:: SpeechServiceResponse_RecognitionLatencyMs

      The recognition latency in milliseconds. Read-only, available on final
      speech/translation/intent results. This measures the latency between
      when an audio input is received by the SDK, and the moment the final
      result is received from the service. The SDK computes the time
      difference between the last audio fragment from the audio input that is
      contributing to the final result, and the time the final result is
      received from the speech service.

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: CancellationDetails_Reason

      The cancellation reason. Currently unused.

    .. py:attribute:: CancellationDetails_ReasonText

      The cancellation text. Currently unused.

    .. py:attribute:: CancellationDetails_ReasonDetailedText

      The cancellation detailed text. Currently unused.

    .. py:attribute:: LanguageUnderstandingServiceResponse_JsonResult

      The Language Understanding Service response output (in JSON format).
      This property is available as
      :py:obj:`.IntentRecognitionResult.intent_json`.

    .. py:attribute:: AudioConfig_DeviceNameForCapture

      The device name for audio capture. Under normal circumstances, you shouldn't have to
      use this property directly.

      Instead, use the `device_name` parameter to construct a `AudioConfig` instance.

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: AudioConfig_NumberOfChannelsForCapture

      The number of channels for audio capture. Internal use only.

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: AudioConfig_SampleRateForCapture

      The sample rate (in Hz) for audio capture. Internal use only.

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: AudioConfig_BitsPerSampleForCapture

      The number of bits of each sample for audio capture. Internal use only.

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: AudioConfig_AudioSource

      The audio source. Allowed values are "Microphones", "File", and "Stream".

      .. note::
        This property id was added in version 1.3.0.

    .. py:attribute:: Speech_LogFilename

      The file name to write logs.

      .. note::
        This property id was added in version 1.4.0.

    """

DocstringForNoMatchReason= """
   Defines the possible reasons a recognition result might not be
   recognized.

   *Values:*

   .. py:attribute:: NotRecognized

      Indicates that speech was detected, but not recognized.

   .. py:attribute:: InitialSilenceTimeout

      Indicates that the start of the audio stream contained only
      silence, and the service timed out waiting for speech.

   .. py:attribute:: InitialBabbleTimeout

      Indicates that the start of the audio stream contained only
      noise, and the service timed out waiting for speech.

   .. py:attribute:: KeywordNotRecognized

      Indicates that the spotted keyword has been rejected by the
      keyword verification service.

      .. note::
        This property id was added in version 1.5.0.
    """

DocstringForCancellationReason = """
   Defines the possible reasons a recognition result might be
   canceled.

   *Values:*

   .. py:attribute:: Error

      Indicates that an error occurred during speech recognition.

   .. py:attribute:: EndOfStream

      Indicates that the end of the audio stream was reached.
    """

DocstringForCancellationErrorCode = """
   Defines error code in case that CancellationReason is Error.

   *Values:*

   .. py:attribute:: NoError

      No error.
      If CancellationReason is EndOfStream, CancellationErrorCode 
      is set to NoError.

   .. py:attribute:: AuthenticationFailure

      Indicates an authentication error.
      An authentication error occurs if subscription key or authorization
      token is invalid, expired, or does not match the region being used.

   .. py:attribute:: BadRequest

      Indicates that one or more recognition parameters are invalid or
      the audio format is not supported.

   .. py:attribute:: TooManyRequests

      Indicates that the number of parallel requests exceeded the
      number of allowed concurrent transcriptions for the
      subscription.

   .. py:attribute:: Forbidden

      Indicates that the free subscription used by the request ran out
      of quota.

   .. py:attribute:: ConnectionFailure

      Indicates a connection error.

   .. py:attribute:: ServiceTimeout

      Indicates a time-out error when waiting for response from
      service.

   .. py:attribute:: ServiceError

      Indicates that an error is returned by the service.

   .. py:attribute:: ServiceUnavailable

      Indicates that the service is currently unavailable.

   .. py:attribute:: RuntimeError

      Indicates an unexpected runtime error.
    """

DocstringForOutputFormat = """
   *Values:*

   .. py:attribute:: Simple

   .. py:attribute:: Detailed
    """


DocstringForResultReason = """
   Specifies the possible reasons a recognition result might be
   generated.

   *Values:*

   .. py:attribute:: NoMatch

      Indicates speech could not be recognized. More details can be
      found in the :py:class:`.speech.NoMatchDetails` object.

   .. py:attribute:: Canceled

      Indicates that the recognition was canceled. More details can be
      found using the :py:class:`.speech.CancellationDetails` object.

   .. py:attribute:: RecognizingSpeech

      Indicates the speech result contains hypothesis text.

   .. py:attribute:: RecognizedSpeech

      Indicates the speech result contains final text that has been
      recognized. Speech Recognition is now complete for this phrase.

   .. py:attribute:: RecognizingIntent

      Indicates the intent result contains hypothesis text and intent.

   .. py:attribute:: RecognizedIntent

      Indicates the intent result contains final text and intent.
      Speech Recognition and Intent determination are now complete for
      this phrase.

   .. py:attribute:: TranslatingSpeech

      Indicates the translation result contains hypothesis text and
      its translation(s).

   .. py:attribute:: TranslatedSpeech

      Indicates the translation result contains final text and
      corresponding translation(s). Speech Recognition and Translation
      are now complete for this phrase.

   .. py:attribute:: SynthesizingAudio

      Indicates the synthesized audio result contains a non-zero
      amount of audio data

   .. py:attribute:: SynthesizingAudioStarted

      Indicates the synthesis is now started for this phrase.

     .. note::
       Added in version 1.7.0.

   .. py:attribute:: SynthesizingAudioCompleted

      Indicates the synthesized audio is now complete for this phrase.
    """

DocstringForServicePropertyChannel = """
   Defines channels used to pass property settings to service.

   .. note::
     Added in version 1.5.0.

   *Values:*

   .. py:attribute:: UriQueryParameter

      Uses URI query parameter to pass property settings to service.
    """

DocstringForProfanityOption = """
   Defines the setting for the profanity filter.

   .. note::
     Added in version 1.5.0.

   *Values:*

   .. py:attribute:: Masked

   .. py:attribute:: Removed

   .. py:attribute:: Raw

    """
DocstringForStreamStatus = """
   Defines the possible status of audio data stream.

   .. note::
     Added in version 1.7.0.

   *Values:*

   .. py:attribute:: Unknown

      Indicates the audio data stream status is unknown

   .. py:attribute:: NoData

      Indicates the audio data stream contains no data

   .. py:attribute:: PartialData

      Indicates the audio data stream contains partial data of a speak request

   .. py:attribute:: AllData

      Indicates the audio data stream contains all data of a speak request

   .. py:attribute:: Canceled

      Indicates the audio data stream was cancelled
    """

DocstringForSpeechSynthesisOutputFormat = """
   Defines the possible speech synthesis output audio format.

   .. note::
     Added in version 1.7.0.

   *Values:*

   .. py:attribute:: Raw8Khz8BitMonoMULaw

      raw-8khz-8bit-mono-mulaw

   .. py:attribute:: Riff16Khz16KbpsMonoSiren

      riff-16khz-16kbps-mono-siren

   .. py:attribute:: Audio16Khz16KbpsMonoSiren

      audio-16khz-16kbps-mono-siren

   .. py:attribute:: Audio16Khz32KBitRateMonoMp3

      audio-16khz-32kbitrate-mono-mp3

   .. py:attribute:: Audio16Khz128KBitRateMonoMp3

      audio-16khz-128kbitrate-mono-mp3

   .. py:attribute:: Audio16Khz64KBitRateMonoMp3

      audio-16khz-64kbitrate-mono-mp3

   .. py:attribute:: Audio24Khz48KBitRateMonoMp3

      audio-24khz-48kbitrate-mono-mp3

   .. py:attribute:: Audio24Khz96KBitRateMonoMp3

      audio-24khz-96kbitrate-mono-mp3

   .. py:attribute:: Audio24Khz160KBitRateMonoMp3

      audio-24khz-160kbitrate-mono-mp3

   .. py:attribute:: Raw16Khz16BitMonoTrueSilk

      raw-16khz-16bit-mono-truesilk

   .. py:attribute:: Riff16Khz16BitMonoPcm

      riff-16khz-16bit-mono-pcm

   .. py:attribute:: Riff8Khz16BitMonoPcm

      riff-8khz-16bit-mono-pcm

   .. py:attribute:: Riff24Khz16BitMonoPcm

      riff-24khz-16bit-mono-pcm

   .. py:attribute:: Riff8Khz8BitMonoMULaw

      riff-8khz-8bit-mono-mulaw

   .. py:attribute:: Raw16Khz16BitMonoPcm

      raw-16khz-16bit-mono-pcm

   .. py:attribute:: Raw24Khz16BitMonoPcm

      raw-24khz-16bit-mono-pcm

   .. py:attribute:: Raw8Khz16BitMonoPcm

      raw-8khz-16bit-mono-pcm
    """

SHARED_PTR_DISOWN = _speech_py_impl.SHARED_PTR_DISOWN
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self)  :
        return _speech_py_impl.SwigPyIterator_value(self)

    def incr(self, n =1)  :
        return _speech_py_impl.SwigPyIterator_incr(self, n)

    def decr(self, n =1)  :
        return _speech_py_impl.SwigPyIterator_decr(self, n)

    def distance(self, x )  :
        return _speech_py_impl.SwigPyIterator_distance(self, x)

    def equal(self, x )  :
        return _speech_py_impl.SwigPyIterator_equal(self, x)

    def copy(self)  :
        return _speech_py_impl.SwigPyIterator_copy(self)

    def next(self)  :
        return _speech_py_impl.SwigPyIterator_next(self)

    def __next__(self)  :
        return _speech_py_impl.SwigPyIterator___next__(self)

    def previous(self)  :
        return _speech_py_impl.SwigPyIterator_previous(self)

    def advance(self, n )  :
        return _speech_py_impl.SwigPyIterator_advance(self, n)

    def __eq__(self, x )  :
        return _speech_py_impl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x )  :
        return _speech_py_impl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n )  :
        return _speech_py_impl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n )  :
        return _speech_py_impl.SwigPyIterator___isub__(self, n)

    def __add__(self, n )  :
        return _speech_py_impl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args)  :
        return _speech_py_impl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _speech_py_impl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self)  :
        return _speech_py_impl.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)  :
        return _speech_py_impl.StringVector___nonzero__(self)

    def __bool__(self)  :
        return _speech_py_impl.StringVector___bool__(self)

    def __len__(self)  :
        return _speech_py_impl.StringVector___len__(self)

    def __getslice__(self, i , j )  :
        return _speech_py_impl.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args)  :
        return _speech_py_impl.StringVector___setslice__(self, *args)

    def __delslice__(self, i , j )  :
        return _speech_py_impl.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args)  :
        return _speech_py_impl.StringVector___delitem__(self, *args)

    def __getitem__(self, *args)  :
        return _speech_py_impl.StringVector___getitem__(self, *args)

    def __setitem__(self, *args)  :
        return _speech_py_impl.StringVector___setitem__(self, *args)

    def pop(self)  :
        return _speech_py_impl.StringVector_pop(self)

    def append(self, x )  :
        return _speech_py_impl.StringVector_append(self, x)

    def empty(self)  :
        return _speech_py_impl.StringVector_empty(self)

    def size(self)  :
        return _speech_py_impl.StringVector_size(self)

    def swap(self, v )  :
        return _speech_py_impl.StringVector_swap(self, v)

    def begin(self)  :
        return _speech_py_impl.StringVector_begin(self)

    def end(self)  :
        return _speech_py_impl.StringVector_end(self)

    def rbegin(self)  :
        return _speech_py_impl.StringVector_rbegin(self)

    def rend(self)  :
        return _speech_py_impl.StringVector_rend(self)

    def clear(self)  :
        return _speech_py_impl.StringVector_clear(self)

    def get_allocator(self)  :
        return _speech_py_impl.StringVector_get_allocator(self)

    def pop_back(self)  :
        return _speech_py_impl.StringVector_pop_back(self)

    def erase(self, *args)  :
        return _speech_py_impl.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _speech_py_impl.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x )  :
        return _speech_py_impl.StringVector_push_back(self, x)

    def front(self)  :
        return _speech_py_impl.StringVector_front(self)

    def back(self)  :
        return _speech_py_impl.StringVector_back(self)

    def assign(self, n , x )  :
        return _speech_py_impl.StringVector_assign(self, n, x)

    def resize(self, *args)  :
        return _speech_py_impl.StringVector_resize(self, *args)

    def insert(self, *args)  :
        return _speech_py_impl.StringVector_insert(self, *args)

    def reserve(self, n )  :
        return _speech_py_impl.StringVector_reserve(self, n)

    def capacity(self)  :
        return _speech_py_impl.StringVector_capacity(self)
    __swig_destroy__ = _speech_py_impl.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _speech_py_impl.StringVector_swigregister
StringVector_swigregister(StringVector)

class StdMapStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdMapStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdMapStringString, name)
    __repr__ = _swig_repr

    def iterator(self)  :
        return _speech_py_impl.StdMapStringString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)  :
        return _speech_py_impl.StdMapStringString___nonzero__(self)

    def __bool__(self)  :
        return _speech_py_impl.StdMapStringString___bool__(self)

    def __len__(self)  :
        return _speech_py_impl.StdMapStringString___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key )  :
        return _speech_py_impl.StdMapStringString___getitem__(self, key)

    def __delitem__(self, key )  :
        return _speech_py_impl.StdMapStringString___delitem__(self, key)

    def has_key(self, key )  :
        return _speech_py_impl.StdMapStringString_has_key(self, key)

    def keys(self)  :
        return _speech_py_impl.StdMapStringString_keys(self)

    def values(self)  :
        return _speech_py_impl.StdMapStringString_values(self)

    def items(self)  :
        return _speech_py_impl.StdMapStringString_items(self)

    def __contains__(self, key )  :
        return _speech_py_impl.StdMapStringString___contains__(self, key)

    def key_iterator(self)  :
        return _speech_py_impl.StdMapStringString_key_iterator(self)

    def value_iterator(self)  :
        return _speech_py_impl.StdMapStringString_value_iterator(self)

    def __setitem__(self, *args)  :
        return _speech_py_impl.StdMapStringString___setitem__(self, *args)

    def asdict(self)  :
        return _speech_py_impl.StdMapStringString_asdict(self)

    def __init__(self, *args):
        this = _speech_py_impl.new_StdMapStringString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self)  :
        return _speech_py_impl.StdMapStringString_empty(self)

    def size(self)  :
        return _speech_py_impl.StdMapStringString_size(self)

    def swap(self, v )  :
        return _speech_py_impl.StdMapStringString_swap(self, v)

    def begin(self)  :
        return _speech_py_impl.StdMapStringString_begin(self)

    def end(self)  :
        return _speech_py_impl.StdMapStringString_end(self)

    def rbegin(self)  :
        return _speech_py_impl.StdMapStringString_rbegin(self)

    def rend(self)  :
        return _speech_py_impl.StdMapStringString_rend(self)

    def clear(self)  :
        return _speech_py_impl.StdMapStringString_clear(self)

    def get_allocator(self)  :
        return _speech_py_impl.StdMapStringString_get_allocator(self)

    def count(self, x )  :
        return _speech_py_impl.StdMapStringString_count(self, x)

    def erase(self, *args)  :
        return _speech_py_impl.StdMapStringString_erase(self, *args)

    def find(self, x )  :
        return _speech_py_impl.StdMapStringString_find(self, x)

    def lower_bound(self, x )  :
        return _speech_py_impl.StdMapStringString_lower_bound(self, x)

    def upper_bound(self, x )  :
        return _speech_py_impl.StdMapStringString_upper_bound(self, x)
    __swig_destroy__ = _speech_py_impl.delete_StdMapStringString
    __del__ = lambda self: None
StdMapStringString_swigregister = _speech_py_impl.StdMapStringString_swigregister
StdMapStringString_swigregister(StdMapStringString)

class Uint8Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Uint8Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Uint8Vector, name)
    __repr__ = _swig_repr

    def iterator(self)  :
        return _speech_py_impl.Uint8Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)  :
        return _speech_py_impl.Uint8Vector___nonzero__(self)

    def __bool__(self)  :
        return _speech_py_impl.Uint8Vector___bool__(self)

    def __len__(self)  :
        return _speech_py_impl.Uint8Vector___len__(self)

    def __getslice__(self, i , j )  :
        return _speech_py_impl.Uint8Vector___getslice__(self, i, j)

    def __setslice__(self, *args)  :
        return _speech_py_impl.Uint8Vector___setslice__(self, *args)

    def __delslice__(self, i , j )  :
        return _speech_py_impl.Uint8Vector___delslice__(self, i, j)

    def __delitem__(self, *args)  :
        return _speech_py_impl.Uint8Vector___delitem__(self, *args)

    def __getitem__(self, *args)  :
        return _speech_py_impl.Uint8Vector___getitem__(self, *args)

    def __setitem__(self, *args)  :
        return _speech_py_impl.Uint8Vector___setitem__(self, *args)

    def pop(self)  :
        return _speech_py_impl.Uint8Vector_pop(self)

    def append(self, x )  :
        return _speech_py_impl.Uint8Vector_append(self, x)

    def empty(self)  :
        return _speech_py_impl.Uint8Vector_empty(self)

    def size(self)  :
        return _speech_py_impl.Uint8Vector_size(self)

    def swap(self, v )  :
        return _speech_py_impl.Uint8Vector_swap(self, v)

    def begin(self)  :
        return _speech_py_impl.Uint8Vector_begin(self)

    def end(self)  :
        return _speech_py_impl.Uint8Vector_end(self)

    def rbegin(self)  :
        return _speech_py_impl.Uint8Vector_rbegin(self)

    def rend(self)  :
        return _speech_py_impl.Uint8Vector_rend(self)

    def clear(self)  :
        return _speech_py_impl.Uint8Vector_clear(self)

    def get_allocator(self)  :
        return _speech_py_impl.Uint8Vector_get_allocator(self)

    def pop_back(self)  :
        return _speech_py_impl.Uint8Vector_pop_back(self)

    def erase(self, *args)  :
        return _speech_py_impl.Uint8Vector_erase(self, *args)

    def __init__(self, *args):
        this = _speech_py_impl.new_Uint8Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x )  :
        return _speech_py_impl.Uint8Vector_push_back(self, x)

    def front(self)  :
        return _speech_py_impl.Uint8Vector_front(self)

    def back(self)  :
        return _speech_py_impl.Uint8Vector_back(self)

    def assign(self, n , x )  :
        return _speech_py_impl.Uint8Vector_assign(self, n, x)

    def resize(self, *args)  :
        return _speech_py_impl.Uint8Vector_resize(self, *args)

    def insert(self, *args)  :
        return _speech_py_impl.Uint8Vector_insert(self, *args)

    def reserve(self, n )  :
        return _speech_py_impl.Uint8Vector_reserve(self, n)

    def capacity(self)  :
        return _speech_py_impl.Uint8Vector_capacity(self)
    __swig_destroy__ = _speech_py_impl.delete_Uint8Vector
    __del__ = lambda self: None
Uint8Vector_swigregister = _speech_py_impl.Uint8Vector_swigregister
Uint8Vector_swigregister(Uint8Vector)


def copy_and_free_property_string(value )  :
    return _speech_py_impl.copy_and_free_property_string(value)
copy_and_free_property_string = _speech_py_impl.copy_and_free_property_string
PropertyId_SpeechServiceConnection_Key = _speech_py_impl.PropertyId_SpeechServiceConnection_Key
PropertyId_SpeechServiceConnection_Endpoint = _speech_py_impl.PropertyId_SpeechServiceConnection_Endpoint
PropertyId_SpeechServiceConnection_Region = _speech_py_impl.PropertyId_SpeechServiceConnection_Region
PropertyId_SpeechServiceAuthorization_Token = _speech_py_impl.PropertyId_SpeechServiceAuthorization_Token
PropertyId_SpeechServiceAuthorization_Type = _speech_py_impl.PropertyId_SpeechServiceAuthorization_Type
PropertyId_SpeechServiceConnection_EndpointId = _speech_py_impl.PropertyId_SpeechServiceConnection_EndpointId
PropertyId_SpeechServiceConnection_Host = _speech_py_impl.PropertyId_SpeechServiceConnection_Host
PropertyId_SpeechServiceConnection_ProxyHostName = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyHostName
PropertyId_SpeechServiceConnection_ProxyPort = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyPort
PropertyId_SpeechServiceConnection_ProxyUserName = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyUserName
PropertyId_SpeechServiceConnection_ProxyPassword = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyPassword
PropertyId_SpeechServiceConnection_Url = _speech_py_impl.PropertyId_SpeechServiceConnection_Url
PropertyId_SpeechServiceConnection_TranslationToLanguages = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationToLanguages
PropertyId_SpeechServiceConnection_TranslationVoice = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationVoice
PropertyId_SpeechServiceConnection_TranslationFeatures = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationFeatures
PropertyId_SpeechServiceConnection_IntentRegion = _speech_py_impl.PropertyId_SpeechServiceConnection_IntentRegion
PropertyId_SpeechServiceConnection_RecoMode = _speech_py_impl.PropertyId_SpeechServiceConnection_RecoMode
PropertyId_SpeechServiceConnection_RecoLanguage = _speech_py_impl.PropertyId_SpeechServiceConnection_RecoLanguage
PropertyId_Speech_SessionId = _speech_py_impl.PropertyId_Speech_SessionId
PropertyId_SpeechServiceConnection_UserDefinedQueryParameters = _speech_py_impl.PropertyId_SpeechServiceConnection_UserDefinedQueryParameters
PropertyId_SpeechServiceConnection_SynthLanguage = _speech_py_impl.PropertyId_SpeechServiceConnection_SynthLanguage
PropertyId_SpeechServiceConnection_SynthVoice = _speech_py_impl.PropertyId_SpeechServiceConnection_SynthVoice
PropertyId_SpeechServiceConnection_SynthOutputFormat = _speech_py_impl.PropertyId_SpeechServiceConnection_SynthOutputFormat
PropertyId_SpeechServiceConnection_InitialSilenceTimeoutMs = _speech_py_impl.PropertyId_SpeechServiceConnection_InitialSilenceTimeoutMs
PropertyId_SpeechServiceConnection_EndSilenceTimeoutMs = _speech_py_impl.PropertyId_SpeechServiceConnection_EndSilenceTimeoutMs
PropertyId_SpeechServiceConnection_EnableAudioLogging = _speech_py_impl.PropertyId_SpeechServiceConnection_EnableAudioLogging
PropertyId_SpeechServiceConnection_AutoDetectSourceLanguages = _speech_py_impl.PropertyId_SpeechServiceConnection_AutoDetectSourceLanguages
PropertyId_SpeechServiceConnection_AutoDetectSourceLanguageResult = _speech_py_impl.PropertyId_SpeechServiceConnection_AutoDetectSourceLanguageResult
PropertyId_SpeechServiceResponse_RequestDetailedResultTrueFalse = _speech_py_impl.PropertyId_SpeechServiceResponse_RequestDetailedResultTrueFalse
PropertyId_SpeechServiceResponse_RequestProfanityFilterTrueFalse = _speech_py_impl.PropertyId_SpeechServiceResponse_RequestProfanityFilterTrueFalse
PropertyId_SpeechServiceResponse_ProfanityOption = _speech_py_impl.PropertyId_SpeechServiceResponse_ProfanityOption
PropertyId_SpeechServiceResponse_PostProcessingOption = _speech_py_impl.PropertyId_SpeechServiceResponse_PostProcessingOption
PropertyId_SpeechServiceResponse_RequestWordLevelTimestamps = _speech_py_impl.PropertyId_SpeechServiceResponse_RequestWordLevelTimestamps
PropertyId_SpeechServiceResponse_StablePartialResultThreshold = _speech_py_impl.PropertyId_SpeechServiceResponse_StablePartialResultThreshold
PropertyId_SpeechServiceResponse_OutputFormatOption = _speech_py_impl.PropertyId_SpeechServiceResponse_OutputFormatOption
PropertyId_SpeechServiceResponse_TranslationRequestStablePartialResult = _speech_py_impl.PropertyId_SpeechServiceResponse_TranslationRequestStablePartialResult
PropertyId_SpeechServiceResponse_JsonResult = _speech_py_impl.PropertyId_SpeechServiceResponse_JsonResult
PropertyId_SpeechServiceResponse_JsonErrorDetails = _speech_py_impl.PropertyId_SpeechServiceResponse_JsonErrorDetails
PropertyId_SpeechServiceResponse_RecognitionLatencyMs = _speech_py_impl.PropertyId_SpeechServiceResponse_RecognitionLatencyMs
PropertyId_CancellationDetails_Reason = _speech_py_impl.PropertyId_CancellationDetails_Reason
PropertyId_CancellationDetails_ReasonText = _speech_py_impl.PropertyId_CancellationDetails_ReasonText
PropertyId_CancellationDetails_ReasonDetailedText = _speech_py_impl.PropertyId_CancellationDetails_ReasonDetailedText
PropertyId_LanguageUnderstandingServiceResponse_JsonResult = _speech_py_impl.PropertyId_LanguageUnderstandingServiceResponse_JsonResult
PropertyId_AudioConfig_DeviceNameForCapture = _speech_py_impl.PropertyId_AudioConfig_DeviceNameForCapture
PropertyId_AudioConfig_NumberOfChannelsForCapture = _speech_py_impl.PropertyId_AudioConfig_NumberOfChannelsForCapture
PropertyId_AudioConfig_SampleRateForCapture = _speech_py_impl.PropertyId_AudioConfig_SampleRateForCapture
PropertyId_AudioConfig_BitsPerSampleForCapture = _speech_py_impl.PropertyId_AudioConfig_BitsPerSampleForCapture
PropertyId_AudioConfig_AudioSource = _speech_py_impl.PropertyId_AudioConfig_AudioSource
PropertyId_Speech_LogFilename = _speech_py_impl.PropertyId_Speech_LogFilename
PropertyId_Conversation_ApplicationId = _speech_py_impl.PropertyId_Conversation_ApplicationId
PropertyId_Conversation_DialogType = _speech_py_impl.PropertyId_Conversation_DialogType
PropertyId_Conversation_Initial_Silence_Timeout = _speech_py_impl.PropertyId_Conversation_Initial_Silence_Timeout
PropertyId_Conversation_From_Id = _speech_py_impl.PropertyId_Conversation_From_Id
PropertyId_Conversation_Conversation_Id = _speech_py_impl.PropertyId_Conversation_Conversation_Id
PropertyId_Conversation_Custom_Voice_Deployment_Ids = _speech_py_impl.PropertyId_Conversation_Custom_Voice_Deployment_Ids
PropertyId_DataBuffer_TimeStamp = _speech_py_impl.PropertyId_DataBuffer_TimeStamp
PropertyId_DataBuffer_UserId = _speech_py_impl.PropertyId_DataBuffer_UserId
OutputFormat_Simple = _speech_py_impl.OutputFormat_Simple
OutputFormat_Detailed = _speech_py_impl.OutputFormat_Detailed
ProfanityOption_Masked = _speech_py_impl.ProfanityOption_Masked
ProfanityOption_Removed = _speech_py_impl.ProfanityOption_Removed
ProfanityOption_Raw = _speech_py_impl.ProfanityOption_Raw
ResultReason_NoMatch = _speech_py_impl.ResultReason_NoMatch
ResultReason_Canceled = _speech_py_impl.ResultReason_Canceled
ResultReason_RecognizingSpeech = _speech_py_impl.ResultReason_RecognizingSpeech
ResultReason_RecognizedSpeech = _speech_py_impl.ResultReason_RecognizedSpeech
ResultReason_RecognizingIntent = _speech_py_impl.ResultReason_RecognizingIntent
ResultReason_RecognizedIntent = _speech_py_impl.ResultReason_RecognizedIntent
ResultReason_TranslatingSpeech = _speech_py_impl.ResultReason_TranslatingSpeech
ResultReason_TranslatedSpeech = _speech_py_impl.ResultReason_TranslatedSpeech
ResultReason_SynthesizingAudio = _speech_py_impl.ResultReason_SynthesizingAudio
ResultReason_SynthesizingAudioCompleted = _speech_py_impl.ResultReason_SynthesizingAudioCompleted
ResultReason_RecognizingKeyword = _speech_py_impl.ResultReason_RecognizingKeyword
ResultReason_RecognizedKeyword = _speech_py_impl.ResultReason_RecognizedKeyword
ResultReason_SynthesizingAudioStarted = _speech_py_impl.ResultReason_SynthesizingAudioStarted
ResultReason_TranslatingParticipantSpeech = _speech_py_impl.ResultReason_TranslatingParticipantSpeech
ResultReason_TranslatedParticipantSpeech = _speech_py_impl.ResultReason_TranslatedParticipantSpeech
ResultReason_TranslatedInstantMessage = _speech_py_impl.ResultReason_TranslatedInstantMessage
ResultReason_TranslatedParticipantInstantMessage = _speech_py_impl.ResultReason_TranslatedParticipantInstantMessage
CancellationReason_Error = _speech_py_impl.CancellationReason_Error
CancellationReason_EndOfStream = _speech_py_impl.CancellationReason_EndOfStream
CancellationErrorCode_NoError = _speech_py_impl.CancellationErrorCode_NoError
CancellationErrorCode_AuthenticationFailure = _speech_py_impl.CancellationErrorCode_AuthenticationFailure
CancellationErrorCode_BadRequest = _speech_py_impl.CancellationErrorCode_BadRequest
CancellationErrorCode_TooManyRequests = _speech_py_impl.CancellationErrorCode_TooManyRequests
CancellationErrorCode_Forbidden = _speech_py_impl.CancellationErrorCode_Forbidden
CancellationErrorCode_ConnectionFailure = _speech_py_impl.CancellationErrorCode_ConnectionFailure
CancellationErrorCode_ServiceTimeout = _speech_py_impl.CancellationErrorCode_ServiceTimeout
CancellationErrorCode_ServiceError = _speech_py_impl.CancellationErrorCode_ServiceError
CancellationErrorCode_ServiceUnavailable = _speech_py_impl.CancellationErrorCode_ServiceUnavailable
CancellationErrorCode_RuntimeError = _speech_py_impl.CancellationErrorCode_RuntimeError
NoMatchReason_NotRecognized = _speech_py_impl.NoMatchReason_NotRecognized
NoMatchReason_InitialSilenceTimeout = _speech_py_impl.NoMatchReason_InitialSilenceTimeout
NoMatchReason_InitialBabbleTimeout = _speech_py_impl.NoMatchReason_InitialBabbleTimeout
NoMatchReason_KeywordNotRecognized = _speech_py_impl.NoMatchReason_KeywordNotRecognized
ActivityJSONType_Null = _speech_py_impl.ActivityJSONType_Null
ActivityJSONType_Object = _speech_py_impl.ActivityJSONType_Object
ActivityJSONType_Array = _speech_py_impl.ActivityJSONType_Array
ActivityJSONType_String = _speech_py_impl.ActivityJSONType_String
ActivityJSONType_Double = _speech_py_impl.ActivityJSONType_Double
ActivityJSONType_UInt = _speech_py_impl.ActivityJSONType_UInt
ActivityJSONType_Int = _speech_py_impl.ActivityJSONType_Int
ActivityJSONType_Boolean = _speech_py_impl.ActivityJSONType_Boolean
SpeechSynthesisOutputFormat_Raw8Khz8BitMonoMULaw = _speech_py_impl.SpeechSynthesisOutputFormat_Raw8Khz8BitMonoMULaw
SpeechSynthesisOutputFormat_Riff16Khz16KbpsMonoSiren = _speech_py_impl.SpeechSynthesisOutputFormat_Riff16Khz16KbpsMonoSiren
SpeechSynthesisOutputFormat_Audio16Khz16KbpsMonoSiren = _speech_py_impl.SpeechSynthesisOutputFormat_Audio16Khz16KbpsMonoSiren
SpeechSynthesisOutputFormat_Audio16Khz32KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio16Khz32KBitRateMonoMp3
SpeechSynthesisOutputFormat_Audio16Khz128KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio16Khz128KBitRateMonoMp3
SpeechSynthesisOutputFormat_Audio16Khz64KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio16Khz64KBitRateMonoMp3
SpeechSynthesisOutputFormat_Audio24Khz48KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio24Khz48KBitRateMonoMp3
SpeechSynthesisOutputFormat_Audio24Khz96KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio24Khz96KBitRateMonoMp3
SpeechSynthesisOutputFormat_Audio24Khz160KBitRateMonoMp3 = _speech_py_impl.SpeechSynthesisOutputFormat_Audio24Khz160KBitRateMonoMp3
SpeechSynthesisOutputFormat_Raw16Khz16BitMonoTrueSilk = _speech_py_impl.SpeechSynthesisOutputFormat_Raw16Khz16BitMonoTrueSilk
SpeechSynthesisOutputFormat_Riff16Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Riff16Khz16BitMonoPcm
SpeechSynthesisOutputFormat_Riff8Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Riff8Khz16BitMonoPcm
SpeechSynthesisOutputFormat_Riff24Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Riff24Khz16BitMonoPcm
SpeechSynthesisOutputFormat_Riff8Khz8BitMonoMULaw = _speech_py_impl.SpeechSynthesisOutputFormat_Riff8Khz8BitMonoMULaw
SpeechSynthesisOutputFormat_Raw16Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Raw16Khz16BitMonoPcm
SpeechSynthesisOutputFormat_Raw24Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Raw24Khz16BitMonoPcm
SpeechSynthesisOutputFormat_Raw8Khz16BitMonoPcm = _speech_py_impl.SpeechSynthesisOutputFormat_Raw8Khz16BitMonoPcm
StreamStatus_Unknown = _speech_py_impl.StreamStatus_Unknown
StreamStatus_NoData = _speech_py_impl.StreamStatus_NoData
StreamStatus_PartialData = _speech_py_impl.StreamStatus_PartialData
StreamStatus_AllData = _speech_py_impl.StreamStatus_AllData
StreamStatus_Canceled = _speech_py_impl.StreamStatus_Canceled
ServicePropertyChannel_UriQueryParameter = _speech_py_impl.ServicePropertyChannel_UriQueryParameter
ResourceHandling_DestroyResources = _speech_py_impl.ResourceHandling_DestroyResources
ResourceHandling_KeepResources = _speech_py_impl.ResourceHandling_KeepResources
ParticipantChangedReason_JoinedConversation = _speech_py_impl.ParticipantChangedReason_JoinedConversation
ParticipantChangedReason_LeftConversation = _speech_py_impl.ParticipantChangedReason_LeftConversation
ParticipantChangedReason_Updated = _speech_py_impl.ParticipantChangedReason_Updated
class SpeechRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.SpeechRecognitionResultPtrFuture_get(self)
SpeechRecognitionResultPtrFuture_swigregister = _speech_py_impl.SpeechRecognitionResultPtrFuture_swigregister
SpeechRecognitionResultPtrFuture_swigregister(SpeechRecognitionResultPtrFuture)
cvar = _speech_py_impl.cvar
TrueString = cvar.TrueString
FalseString = cvar.FalseString
CommaDelim = cvar.CommaDelim

class IntentRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.IntentRecognitionResultPtrFuture_get(self)
IntentRecognitionResultPtrFuture_swigregister = _speech_py_impl.IntentRecognitionResultPtrFuture_swigregister
IntentRecognitionResultPtrFuture_swigregister(IntentRecognitionResultPtrFuture)

class TranslationRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.TranslationRecognitionResultPtrFuture_get(self)
TranslationRecognitionResultPtrFuture_swigregister = _speech_py_impl.TranslationRecognitionResultPtrFuture_swigregister
TranslationRecognitionResultPtrFuture_swigregister(TranslationRecognitionResultPtrFuture)

class SpeechSynthesisResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisResultPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.SpeechSynthesisResultPtrFuture_get(self)
SpeechSynthesisResultPtrFuture_swigregister = _speech_py_impl.SpeechSynthesisResultPtrFuture_swigregister
SpeechSynthesisResultPtrFuture_swigregister(SpeechSynthesisResultPtrFuture)

class StringFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_StringFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.StringFuture_get(self)
StringFuture_swigregister = _speech_py_impl.StringFuture_swigregister
StringFuture_swigregister(StringFuture)

class VoidFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VoidFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VoidFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_VoidFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.VoidFuture_get(self)
VoidFuture_swigregister = _speech_py_impl.VoidFuture_swigregister
VoidFuture_swigregister(VoidFuture)

class SourceLanguageConfigPtrVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SourceLanguageConfigPtrVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SourceLanguageConfigPtrVector, name)
    __repr__ = _swig_repr

    def iterator(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___nonzero__(self)

    def __bool__(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___bool__(self)

    def __len__(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___len__(self)

    def __getslice__(self, i , j )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___setslice__(self, *args)

    def __delslice__(self, i , j )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___delitem__(self, *args)

    def __getitem__(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___getitem__(self, *args)

    def __setitem__(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector___setitem__(self, *args)

    def pop(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_pop(self)

    def append(self, x )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_append(self, x)

    def empty(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_empty(self)

    def size(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_size(self)

    def swap(self, v )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_swap(self, v)

    def begin(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_begin(self)

    def end(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_end(self)

    def rbegin(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_rbegin(self)

    def rend(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_rend(self)

    def clear(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_clear(self)

    def get_allocator(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_get_allocator(self)

    def pop_back(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_pop_back(self)

    def erase(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_erase(self, *args)

    def __init__(self, *args):
        this = _speech_py_impl.new_SourceLanguageConfigPtrVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_push_back(self, x)

    def front(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_front(self)

    def back(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_back(self)

    def assign(self, n , x )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_assign(self, n, x)

    def resize(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_resize(self, *args)

    def insert(self, *args)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_insert(self, *args)

    def reserve(self, n )  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_reserve(self, n)

    def capacity(self)  :
        return _speech_py_impl.SourceLanguageConfigPtrVector_capacity(self)
    __swig_destroy__ = _speech_py_impl.delete_SourceLanguageConfigPtrVector
    __del__ = lambda self: None
SourceLanguageConfigPtrVector_swigregister = _speech_py_impl.SourceLanguageConfigPtrVector_swigregister
SourceLanguageConfigPtrVector_swigregister(SourceLanguageConfigPtrVector)

class ParticipantPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticipantPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticipantPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ParticipantPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.ParticipantPtrFuture_get(self)
ParticipantPtrFuture_swigregister = _speech_py_impl.ParticipantPtrFuture_swigregister
ParticipantPtrFuture_swigregister(ParticipantPtrFuture)

class UserPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_UserPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.UserPtrFuture_get(self)
UserPtrFuture_swigregister = _speech_py_impl.UserPtrFuture_swigregister
UserPtrFuture_swigregister(UserPtrFuture)

class ConversationPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ConversationPtrFuture
    __del__ = lambda self: None

    def get(self)  :
        return _speech_py_impl.ConversationPtrFuture_get(self)
ConversationPtrFuture_swigregister = _speech_py_impl.ConversationPtrFuture_swigregister
ConversationPtrFuture_swigregister(ConversationPtrFuture)

class SpeechConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.SpeechConfig__from_subscription)
    else:
        _from_subscription = _speech_py_impl.SpeechConfig__from_subscription
    if _newclass:
        _from_authorization_token = staticmethod(_speech_py_impl.SpeechConfig__from_authorization_token)
    else:
        _from_authorization_token = _speech_py_impl.SpeechConfig__from_authorization_token
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.SpeechConfig__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.SpeechConfig__from_endpoint
    if _newclass:
        _from_host = staticmethod(_speech_py_impl.SpeechConfig__from_host)
    else:
        _from_host = _speech_py_impl.SpeechConfig__from_host

    def set_speech_recognition_language(self, lang )  :
        return _speech_py_impl.SpeechConfig_set_speech_recognition_language(self, lang)

    def get_speech_recognition_language(self)  :
        return _speech_py_impl.SpeechConfig_get_speech_recognition_language(self)

    def set_speech_synthesis_language(self, lang )  :
        return _speech_py_impl.SpeechConfig_set_speech_synthesis_language(self, lang)

    def get_speech_synthesis_language(self)  :
        return _speech_py_impl.SpeechConfig_get_speech_synthesis_language(self)

    def set_speech_synthesis_voice_name(self, voiceName )  :
        return _speech_py_impl.SpeechConfig_set_speech_synthesis_voice_name(self, voiceName)

    def get_speech_synthesis_voice_name(self)  :
        return _speech_py_impl.SpeechConfig_get_speech_synthesis_voice_name(self)

    def set_speech_synthesis_output_format(self, formatId )  :
        return _speech_py_impl.SpeechConfig_set_speech_synthesis_output_format(self, formatId)

    def get_speech_synthesis_output_format(self)  :
        return _speech_py_impl.SpeechConfig_get_speech_synthesis_output_format(self)

    def set_endpoint_id(self, endpointId )  :
        return _speech_py_impl.SpeechConfig_set_endpoint_id(self, endpointId)

    def get_endpoint_id(self)  :
        return _speech_py_impl.SpeechConfig_get_endpoint_id(self)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.SpeechConfig_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.SpeechConfig_get_authorization_token(self)

    def get_subscription_key(self)  :
        return _speech_py_impl.SpeechConfig_get_subscription_key(self)

    def get_region(self)  :
        return _speech_py_impl.SpeechConfig_get_region(self)

    def get_output_format(self)  :
        return _speech_py_impl.SpeechConfig_get_output_format(self)

    def set_output_format(self, format )  :
        return _speech_py_impl.SpeechConfig_set_output_format(self, format)

    def set_profanity(self, profanity )  :
        return _speech_py_impl.SpeechConfig_set_profanity(self, profanity)

    def enable_audio_logging(self)  :
        return _speech_py_impl.SpeechConfig_enable_audio_logging(self)

    def request_word_level_timestamps(self)  :
        return _speech_py_impl.SpeechConfig_request_word_level_timestamps(self)

    def enable_dictation(self)  :
        return _speech_py_impl.SpeechConfig_enable_dictation(self)

    def set_proxy(self, *args)  :
        return _speech_py_impl.SpeechConfig_set_proxy(self, *args)

    def get_property(self, *args)  :
        return _speech_py_impl.SpeechConfig_get_property(self, *args)

    def set_property(self, *args)  :
        return _speech_py_impl.SpeechConfig_set_property(self, *args)

    def set_service_property(self, name , value , channel )  :
        return _speech_py_impl.SpeechConfig_set_service_property(self, name, value, channel)
    __swig_destroy__ = _speech_py_impl.delete_SpeechConfig
    __del__ = lambda self: None
SpeechConfig_swigregister = _speech_py_impl.SpeechConfig_swigregister
SpeechConfig_swigregister(SpeechConfig)

def SpeechConfig__from_subscription(subscription , region )  :
    return _speech_py_impl.SpeechConfig__from_subscription(subscription, region)
SpeechConfig__from_subscription = _speech_py_impl.SpeechConfig__from_subscription

def SpeechConfig__from_authorization_token(authToken , region )  :
    return _speech_py_impl.SpeechConfig__from_authorization_token(authToken, region)
SpeechConfig__from_authorization_token = _speech_py_impl.SpeechConfig__from_authorization_token

def SpeechConfig__from_endpoint(*args)  :
    return _speech_py_impl.SpeechConfig__from_endpoint(*args)
SpeechConfig__from_endpoint = _speech_py_impl.SpeechConfig__from_endpoint

def SpeechConfig__from_host(*args)  :
    return _speech_py_impl.SpeechConfig__from_host(*args)
SpeechConfig__from_host = _speech_py_impl.SpeechConfig__from_host

class SpeechTranslationConfig(SpeechConfig):
    __swig_setmethods__ = {}
    for _s in [SpeechConfig]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechTranslationConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechConfig]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechTranslationConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_subscription)
    else:
        _from_subscription = _speech_py_impl.SpeechTranslationConfig__from_subscription
    if _newclass:
        _from_authorization_token = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_authorization_token)
    else:
        _from_authorization_token = _speech_py_impl.SpeechTranslationConfig__from_authorization_token
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.SpeechTranslationConfig__from_endpoint
    if _newclass:
        _from_host = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_host)
    else:
        _from_host = _speech_py_impl.SpeechTranslationConfig__from_host

    def add_target_language(self, language )  :
        return _speech_py_impl.SpeechTranslationConfig_add_target_language(self, language)

    def remove_target_language(self, language )  :
        return _speech_py_impl.SpeechTranslationConfig_remove_target_language(self, language)

    def get_target_languages(self)  :
        return _speech_py_impl.SpeechTranslationConfig_get_target_languages(self)

    def set_voice_name(self, voice )  :
        return _speech_py_impl.SpeechTranslationConfig_set_voice_name(self, voice)

    def get_voice_name(self)  :
        return _speech_py_impl.SpeechTranslationConfig_get_voice_name(self)
    __swig_destroy__ = _speech_py_impl.delete_SpeechTranslationConfig
    __del__ = lambda self: None
SpeechTranslationConfig_swigregister = _speech_py_impl.SpeechTranslationConfig_swigregister
SpeechTranslationConfig_swigregister(SpeechTranslationConfig)

def SpeechTranslationConfig__from_subscription(subscription , region )  :
    return _speech_py_impl.SpeechTranslationConfig__from_subscription(subscription, region)
SpeechTranslationConfig__from_subscription = _speech_py_impl.SpeechTranslationConfig__from_subscription

def SpeechTranslationConfig__from_authorization_token(authToken , region )  :
    return _speech_py_impl.SpeechTranslationConfig__from_authorization_token(authToken, region)
SpeechTranslationConfig__from_authorization_token = _speech_py_impl.SpeechTranslationConfig__from_authorization_token

def SpeechTranslationConfig__from_endpoint(*args)  :
    return _speech_py_impl.SpeechTranslationConfig__from_endpoint(*args)
SpeechTranslationConfig__from_endpoint = _speech_py_impl.SpeechTranslationConfig__from_endpoint

def SpeechTranslationConfig__from_host(*args)  :
    return _speech_py_impl.SpeechTranslationConfig__from_host(*args)
SpeechTranslationConfig__from_host = _speech_py_impl.SpeechTranslationConfig__from_host

class DialogServiceConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogServiceConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialogServiceConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_DialogServiceConfig
    __del__ = lambda self: None

    def set_property(self, *args)  :
        return _speech_py_impl.DialogServiceConfig_set_property(self, *args)

    def get_property(self, *args)  :
        return _speech_py_impl.DialogServiceConfig_get_property(self, *args)

    def set_service_property(self, name , value , channel )  :
        return _speech_py_impl.DialogServiceConfig_set_service_property(self, name, value, channel)

    def set_proxy(self, *args)  :
        return _speech_py_impl.DialogServiceConfig_set_proxy(self, *args)

    def set_language(self, lang )  :
        return _speech_py_impl.DialogServiceConfig_set_language(self, lang)

    def get_language(self)  :
        return _speech_py_impl.DialogServiceConfig_get_language(self)
DialogServiceConfig_swigregister = _speech_py_impl.DialogServiceConfig_swigregister
DialogServiceConfig_swigregister(DialogServiceConfig)

class BotFrameworkConfig(DialogServiceConfig):
    __swig_setmethods__ = {}
    for _s in [DialogServiceConfig]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BotFrameworkConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [DialogServiceConfig]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BotFrameworkConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        from_subscription = staticmethod(_speech_py_impl.BotFrameworkConfig_from_subscription)
    else:
        from_subscription = _speech_py_impl.BotFrameworkConfig_from_subscription
    if _newclass:
        from_authorization_token = staticmethod(_speech_py_impl.BotFrameworkConfig_from_authorization_token)
    else:
        from_authorization_token = _speech_py_impl.BotFrameworkConfig_from_authorization_token
    __swig_destroy__ = _speech_py_impl.delete_BotFrameworkConfig
    __del__ = lambda self: None
BotFrameworkConfig_swigregister = _speech_py_impl.BotFrameworkConfig_swigregister
BotFrameworkConfig_swigregister(BotFrameworkConfig)

def BotFrameworkConfig_from_subscription(subscription , region )  :
    return _speech_py_impl.BotFrameworkConfig_from_subscription(subscription, region)
BotFrameworkConfig_from_subscription = _speech_py_impl.BotFrameworkConfig_from_subscription

def BotFrameworkConfig_from_authorization_token(authToken , region )  :
    return _speech_py_impl.BotFrameworkConfig_from_authorization_token(authToken, region)
BotFrameworkConfig_from_authorization_token = _speech_py_impl.BotFrameworkConfig_from_authorization_token

class CustomCommandsConfig(DialogServiceConfig):
    __swig_setmethods__ = {}
    for _s in [DialogServiceConfig]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomCommandsConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [DialogServiceConfig]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomCommandsConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        from_subscription = staticmethod(_speech_py_impl.CustomCommandsConfig_from_subscription)
    else:
        from_subscription = _speech_py_impl.CustomCommandsConfig_from_subscription
    if _newclass:
        from_authorization_token = staticmethod(_speech_py_impl.CustomCommandsConfig_from_authorization_token)
    else:
        from_authorization_token = _speech_py_impl.CustomCommandsConfig_from_authorization_token

    def set_application_id(self, applicationId )  :
        return _speech_py_impl.CustomCommandsConfig_set_application_id(self, applicationId)

    def get_application_id(self)  :
        return _speech_py_impl.CustomCommandsConfig_get_application_id(self)
    __swig_destroy__ = _speech_py_impl.delete_CustomCommandsConfig
    __del__ = lambda self: None
CustomCommandsConfig_swigregister = _speech_py_impl.CustomCommandsConfig_swigregister
CustomCommandsConfig_swigregister(CustomCommandsConfig)

def CustomCommandsConfig_from_subscription(appId , subscription , region )  :
    return _speech_py_impl.CustomCommandsConfig_from_subscription(appId, subscription, region)
CustomCommandsConfig_from_subscription = _speech_py_impl.CustomCommandsConfig_from_subscription

def CustomCommandsConfig_from_authorization_token(appId , authToken , region )  :
    return _speech_py_impl.CustomCommandsConfig_from_authorization_token(appId, authToken, region)
CustomCommandsConfig_from_authorization_token = _speech_py_impl.CustomCommandsConfig_from_authorization_token

class SourceLanguageConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SourceLanguageConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SourceLanguageConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        from_language = staticmethod(_speech_py_impl.SourceLanguageConfig_from_language)
    else:
        from_language = _speech_py_impl.SourceLanguageConfig_from_language
    __swig_destroy__ = _speech_py_impl.delete_SourceLanguageConfig
    __del__ = lambda self: None
SourceLanguageConfig_swigregister = _speech_py_impl.SourceLanguageConfig_swigregister
SourceLanguageConfig_swigregister(SourceLanguageConfig)

def SourceLanguageConfig_from_language(*args)  :
    return _speech_py_impl.SourceLanguageConfig_from_language(*args)
SourceLanguageConfig_from_language = _speech_py_impl.SourceLanguageConfig_from_language

class AutoDetectSourceLanguageConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AutoDetectSourceLanguageConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AutoDetectSourceLanguageConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        from_languages = staticmethod(_speech_py_impl.AutoDetectSourceLanguageConfig_from_languages)
    else:
        from_languages = _speech_py_impl.AutoDetectSourceLanguageConfig_from_languages
    if _newclass:
        from_source_language_configs = staticmethod(_speech_py_impl.AutoDetectSourceLanguageConfig_from_source_language_configs)
    else:
        from_source_language_configs = _speech_py_impl.AutoDetectSourceLanguageConfig_from_source_language_configs
    __swig_destroy__ = _speech_py_impl.delete_AutoDetectSourceLanguageConfig
    __del__ = lambda self: None
AutoDetectSourceLanguageConfig_swigregister = _speech_py_impl.AutoDetectSourceLanguageConfig_swigregister
AutoDetectSourceLanguageConfig_swigregister(AutoDetectSourceLanguageConfig)

def AutoDetectSourceLanguageConfig_from_languages(languages )  :
    return _speech_py_impl.AutoDetectSourceLanguageConfig_from_languages(languages)
AutoDetectSourceLanguageConfig_from_languages = _speech_py_impl.AutoDetectSourceLanguageConfig_from_languages

def AutoDetectSourceLanguageConfig_from_source_language_configs(configList )  :
    return _speech_py_impl.AutoDetectSourceLanguageConfig_from_source_language_configs(configList)
AutoDetectSourceLanguageConfig_from_source_language_configs = _speech_py_impl.AutoDetectSourceLanguageConfig_from_source_language_configs

class PropertyCollection(_object):
    """

    Class to retrieve or set a property value from a property collection.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyCollection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyCollection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PropertyCollection
    __del__ = lambda self: None

    def set_property(self, property_id , value ):
        if not isinstance(property_id, PropertyId):
            raise TypeError('wrong type, must be PropertyId')
        return _speech_py_impl.PropertyCollection_set_property(self, property_id.value, value)


    def get_property(self, property_id , default_value  = '')  :
        if not isinstance(property_id, PropertyId):
            raise TypeError('wrong type, must be PropertyId')
        return _speech_py_impl.PropertyCollection_get_property(self, property_id.value, default_value)

PropertyCollection_swigregister = _speech_py_impl.PropertyCollection_swigregister
PropertyCollection_swigregister(PropertyCollection)

AudioStreamContainerFormat_OGG_OPUS = _speech_py_impl.AudioStreamContainerFormat_OGG_OPUS
AudioStreamContainerFormat_MP3 = _speech_py_impl.AudioStreamContainerFormat_MP3
AudioStreamContainerFormat_FLAC = _speech_py_impl.AudioStreamContainerFormat_FLAC
AudioStreamContainerFormat_ALAW = _speech_py_impl.AudioStreamContainerFormat_ALAW
AudioStreamContainerFormat_MULAW = _speech_py_impl.AudioStreamContainerFormat_MULAW
AudioStreamContainerFormat_AMRNB = _speech_py_impl.AudioStreamContainerFormat_AMRNB
AudioStreamContainerFormat_AMRWB = _speech_py_impl.AudioStreamContainerFormat_AMRWB
class AudioStreamFormat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioStreamFormat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioStreamFormat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_AudioStreamFormat
    __del__ = lambda self: None
    if _newclass:
        get_default_input_format = staticmethod(_speech_py_impl.AudioStreamFormat_get_default_input_format)
    else:
        get_default_input_format = _speech_py_impl.AudioStreamFormat_get_default_input_format
    if _newclass:
        get_wave_format_pcm = staticmethod(_speech_py_impl.AudioStreamFormat_get_wave_format_pcm)
    else:
        get_wave_format_pcm = _speech_py_impl.AudioStreamFormat_get_wave_format_pcm
    if _newclass:
        get_default_output_format = staticmethod(_speech_py_impl.AudioStreamFormat_get_default_output_format)
    else:
        get_default_output_format = _speech_py_impl.AudioStreamFormat_get_default_output_format
    if _newclass:
        get_compressed_format = staticmethod(_speech_py_impl.AudioStreamFormat_get_compressed_format)
    else:
        get_compressed_format = _speech_py_impl.AudioStreamFormat_get_compressed_format
AudioStreamFormat_swigregister = _speech_py_impl.AudioStreamFormat_swigregister
AudioStreamFormat_swigregister(AudioStreamFormat)

def AudioStreamFormat_get_default_input_format()  :
    return _speech_py_impl.AudioStreamFormat_get_default_input_format()
AudioStreamFormat_get_default_input_format = _speech_py_impl.AudioStreamFormat_get_default_input_format

def AudioStreamFormat_get_wave_format_pcm(samplesPerSecond , bitsPerSample =16, channels =1)  :
    return _speech_py_impl.AudioStreamFormat_get_wave_format_pcm(samplesPerSecond, bitsPerSample, channels)
AudioStreamFormat_get_wave_format_pcm = _speech_py_impl.AudioStreamFormat_get_wave_format_pcm

def AudioStreamFormat_get_default_output_format()  :
    return _speech_py_impl.AudioStreamFormat_get_default_output_format()
AudioStreamFormat_get_default_output_format = _speech_py_impl.AudioStreamFormat_get_default_output_format

def AudioStreamFormat_get_compressed_format(compressedFormat )  :
    return _speech_py_impl.AudioStreamFormat_get_compressed_format(compressedFormat)
AudioStreamFormat_get_compressed_format = _speech_py_impl.AudioStreamFormat_get_compressed_format

class AudioInputStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioInputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_AudioInputStream
    __del__ = lambda self: None
AudioInputStream_swigregister = _speech_py_impl.AudioInputStream_swigregister
AudioInputStream_swigregister(AudioInputStream)

class PushAudioInputStream(AudioInputStream):
    __swig_setmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PushAudioInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PushAudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PushAudioInputStream
    __del__ = lambda self: None
    if _newclass:
        create = staticmethod(_speech_py_impl.PushAudioInputStream_create)
    else:
        create = _speech_py_impl.PushAudioInputStream_create

    def write(self, dataBuffer )  :
        return _speech_py_impl.PushAudioInputStream_write(self, dataBuffer)

    def set_property(self, *args)  :
        return _speech_py_impl.PushAudioInputStream_set_property(self, *args)

    def close(self)  :
        return _speech_py_impl.PushAudioInputStream_close(self)
PushAudioInputStream_swigregister = _speech_py_impl.PushAudioInputStream_swigregister
PushAudioInputStream_swigregister(PushAudioInputStream)

def PushAudioInputStream_create(*args)  :
    return _speech_py_impl.PushAudioInputStream_create(*args)
PushAudioInputStream_create = _speech_py_impl.PushAudioInputStream_create

class PullAudioInputStreamCallback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PullAudioInputStreamCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PullAudioInputStreamCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PullAudioInputStreamCallback
    __del__ = lambda self: None

    def read(self, dataBuffer )  :
        return _speech_py_impl.PullAudioInputStreamCallback_read(self, dataBuffer)

    def get_property(self, id )  :
        return _speech_py_impl.PullAudioInputStreamCallback_get_property(self, id)

    def close(self)  :
        return _speech_py_impl.PullAudioInputStreamCallback_close(self)

    def __init__(self):
        if self.__class__ == PullAudioInputStreamCallback:
            _self = None
        else:
            _self = self
        this = _speech_py_impl.new_PullAudioInputStreamCallback(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _speech_py_impl.disown_PullAudioInputStreamCallback(self)
        return weakref_proxy(self)
PullAudioInputStreamCallback_swigregister = _speech_py_impl.PullAudioInputStreamCallback_swigregister
PullAudioInputStreamCallback_swigregister(PullAudioInputStreamCallback)

class PullAudioInputStream(AudioInputStream):
    __swig_setmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PullAudioInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PullAudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_speech_py_impl.PullAudioInputStream_create)
    else:
        create = _speech_py_impl.PullAudioInputStream_create
    __swig_destroy__ = _speech_py_impl.delete_PullAudioInputStream
    __del__ = lambda self: None
PullAudioInputStream_swigregister = _speech_py_impl.PullAudioInputStream_swigregister
PullAudioInputStream_swigregister(PullAudioInputStream)

def PullAudioInputStream_create(*args)  :
    return _speech_py_impl.PullAudioInputStream_create(*args)
PullAudioInputStream_create = _speech_py_impl.PullAudioInputStream_create

class AudioOutputStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioOutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioOutputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_AudioOutputStream
    __del__ = lambda self: None
AudioOutputStream_swigregister = _speech_py_impl.AudioOutputStream_swigregister
AudioOutputStream_swigregister(AudioOutputStream)

class PullAudioOutputStream(AudioOutputStream):
    __swig_setmethods__ = {}
    for _s in [AudioOutputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PullAudioOutputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioOutputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PullAudioOutputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_speech_py_impl.PullAudioOutputStream_create)
    else:
        create = _speech_py_impl.PullAudioOutputStream_create

    def read(self, buffer )  :
        return _speech_py_impl.PullAudioOutputStream_read(self, buffer)
    __swig_destroy__ = _speech_py_impl.delete_PullAudioOutputStream
    __del__ = lambda self: None
PullAudioOutputStream_swigregister = _speech_py_impl.PullAudioOutputStream_swigregister
PullAudioOutputStream_swigregister(PullAudioOutputStream)

def PullAudioOutputStream_create()  :
    return _speech_py_impl.PullAudioOutputStream_create()
PullAudioOutputStream_create = _speech_py_impl.PullAudioOutputStream_create

class PushAudioOutputStreamCallback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PushAudioOutputStreamCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PushAudioOutputStreamCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PushAudioOutputStreamCallback
    __del__ = lambda self: None

    def write(self, dataBuffer )  :
        return _speech_py_impl.PushAudioOutputStreamCallback_write(self, dataBuffer)

    def close(self)  :
        return _speech_py_impl.PushAudioOutputStreamCallback_close(self)

    def __init__(self):
        if self.__class__ == PushAudioOutputStreamCallback:
            _self = None
        else:
            _self = self
        this = _speech_py_impl.new_PushAudioOutputStreamCallback(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _speech_py_impl.disown_PushAudioOutputStreamCallback(self)
        return weakref_proxy(self)
PushAudioOutputStreamCallback_swigregister = _speech_py_impl.PushAudioOutputStreamCallback_swigregister
PushAudioOutputStreamCallback_swigregister(PushAudioOutputStreamCallback)

class PushAudioOutputStream(AudioOutputStream):
    __swig_setmethods__ = {}
    for _s in [AudioOutputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PushAudioOutputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioOutputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PushAudioOutputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_speech_py_impl.PushAudioOutputStream_create)
    else:
        create = _speech_py_impl.PushAudioOutputStream_create
    __swig_destroy__ = _speech_py_impl.delete_PushAudioOutputStream
    __del__ = lambda self: None
PushAudioOutputStream_swigregister = _speech_py_impl.PushAudioOutputStream_swigregister
PushAudioOutputStream_swigregister(PushAudioOutputStream)

def PushAudioOutputStream_create(callback )  :
    return _speech_py_impl.PushAudioOutputStream_create(callback)
PushAudioOutputStream_create = _speech_py_impl.PushAudioOutputStream_create

class AudioConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_default_microphone_input = staticmethod(_speech_py_impl.AudioConfig__from_default_microphone_input)
    else:
        _from_default_microphone_input = _speech_py_impl.AudioConfig__from_default_microphone_input
    if _newclass:
        _from_microphone_input = staticmethod(_speech_py_impl.AudioConfig__from_microphone_input)
    else:
        _from_microphone_input = _speech_py_impl.AudioConfig__from_microphone_input
    if _newclass:
        _from_wav_file_input = staticmethod(_speech_py_impl.AudioConfig__from_wav_file_input)
    else:
        _from_wav_file_input = _speech_py_impl.AudioConfig__from_wav_file_input
    if _newclass:
        _from_stream_input = staticmethod(_speech_py_impl.AudioConfig__from_stream_input)
    else:
        _from_stream_input = _speech_py_impl.AudioConfig__from_stream_input
    if _newclass:
        _from_default_speaker_output = staticmethod(_speech_py_impl.AudioConfig__from_default_speaker_output)
    else:
        _from_default_speaker_output = _speech_py_impl.AudioConfig__from_default_speaker_output
    if _newclass:
        _from_wav_file_output = staticmethod(_speech_py_impl.AudioConfig__from_wav_file_output)
    else:
        _from_wav_file_output = _speech_py_impl.AudioConfig__from_wav_file_output
    if _newclass:
        _from_stream_output = staticmethod(_speech_py_impl.AudioConfig__from_stream_output)
    else:
        _from_stream_output = _speech_py_impl.AudioConfig__from_stream_output

    def set_property(self, *args)  :
        return _speech_py_impl.AudioConfig_set_property(self, *args)

    def get_property(self, *args)  :
        return _speech_py_impl.AudioConfig_get_property(self, *args)
    __swig_destroy__ = _speech_py_impl.delete_AudioConfig
    __del__ = lambda self: None
AudioConfig_swigregister = _speech_py_impl.AudioConfig_swigregister
AudioConfig_swigregister(AudioConfig)

def AudioConfig__from_default_microphone_input()  :
    return _speech_py_impl.AudioConfig__from_default_microphone_input()
AudioConfig__from_default_microphone_input = _speech_py_impl.AudioConfig__from_default_microphone_input

def AudioConfig__from_microphone_input(deviceName )  :
    return _speech_py_impl.AudioConfig__from_microphone_input(deviceName)
AudioConfig__from_microphone_input = _speech_py_impl.AudioConfig__from_microphone_input

def AudioConfig__from_wav_file_input(fileName )  :
    return _speech_py_impl.AudioConfig__from_wav_file_input(fileName)
AudioConfig__from_wav_file_input = _speech_py_impl.AudioConfig__from_wav_file_input

def AudioConfig__from_stream_input(stream )  :
    return _speech_py_impl.AudioConfig__from_stream_input(stream)
AudioConfig__from_stream_input = _speech_py_impl.AudioConfig__from_stream_input

def AudioConfig__from_default_speaker_output()  :
    return _speech_py_impl.AudioConfig__from_default_speaker_output()
AudioConfig__from_default_speaker_output = _speech_py_impl.AudioConfig__from_default_speaker_output

def AudioConfig__from_wav_file_output(fileName )  :
    return _speech_py_impl.AudioConfig__from_wav_file_output(fileName)
AudioConfig__from_wav_file_output = _speech_py_impl.AudioConfig__from_wav_file_output

def AudioConfig__from_stream_output(stream )  :
    return _speech_py_impl.AudioConfig__from_stream_output(stream)
AudioConfig__from_stream_output = _speech_py_impl.AudioConfig__from_stream_output

class KeywordRecognitionModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeywordRecognitionModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeywordRecognitionModel, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_file = staticmethod(_speech_py_impl.KeywordRecognitionModel__from_file)
    else:
        _from_file = _speech_py_impl.KeywordRecognitionModel__from_file

    def __init__(self, *args):
        this = _speech_py_impl.new_KeywordRecognitionModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_KeywordRecognitionModel
    __del__ = lambda self: None
KeywordRecognitionModel_swigregister = _speech_py_impl.KeywordRecognitionModel_swigregister
KeywordRecognitionModel_swigregister(KeywordRecognitionModel)

def KeywordRecognitionModel__from_file(fileName )  :
    return _speech_py_impl.KeywordRecognitionModel__from_file(fileName)
KeywordRecognitionModel__from_file = _speech_py_impl.KeywordRecognitionModel__from_file

class EventArgs(_object):
    """

    Base class for event arguments.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventArgs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_EventArgs
    __del__ = lambda self: None
EventArgs_swigregister = _speech_py_impl.EventArgs_swigregister
EventArgs_swigregister(EventArgs)

class SessionEventArgs(EventArgs):
    """

    Base class for session event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [EventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SessionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SessionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SessionEventArgs
    __del__ = lambda self: None
    __swig_getmethods__["session_id"] = _speech_py_impl.SessionEventArgs_session_id_get
    if _newclass:
        session_id = _swig_property(_speech_py_impl.SessionEventArgs_session_id_get)

    def __str__(self):
        return u'{}:(session_id={})'.format(type(self), self.session_id)

SessionEventArgs_swigregister = _speech_py_impl.SessionEventArgs_swigregister
SessionEventArgs_swigregister(SessionEventArgs)

class ConnectionEventArgs(SessionEventArgs):
    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionEventArgs, name)
    __repr__ = _swig_repr

    def __init__(self, hevent ):
        this = _speech_py_impl.new_ConnectionEventArgs(hevent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConnectionEventArgs
    __del__ = lambda self: None
ConnectionEventArgs_swigregister = _speech_py_impl.ConnectionEventArgs_swigregister
ConnectionEventArgs_swigregister(ConnectionEventArgs)

class RecognitionResult(_object):
    """

    Contains detailed information about the result of a recognition operation.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["result_id"] = _speech_py_impl.RecognitionResult_result_id_get
    if _newclass:
        result_id = _swig_property(_speech_py_impl.RecognitionResult_result_id_get)
    __swig_getmethods__["_reason"] = _speech_py_impl.RecognitionResult__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.RecognitionResult__reason_get)
    __swig_getmethods__["text"] = _speech_py_impl.RecognitionResult_text_get
    if _newclass:
        text = _swig_property(_speech_py_impl.RecognitionResult_text_get)

    def duration(self)  :
        """


        Duration of recognized speech in ticks. A single tick represents one hundred
        nanoseconds or one ten-millionth of a second.

        :return: Duration of recognized speech in ticks.

        """
        return _speech_py_impl.RecognitionResult_duration(self)


    def offset(self)  :
        """


        Offset of the recognized speech in ticks. A single tick represents one hundred
        nanoseconds or one ten-millionth of a second.

        :return: Offset of the recognized speech in ticks.

        """
        return _speech_py_impl.RecognitionResult_offset(self)

    __swig_getmethods__["properties"] = _speech_py_impl.RecognitionResult_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.RecognitionResult_properties_get)

    def __str__(self):
        return u'{}:(result_id={}, text={})'.format(type(self), self.result_id, self.text)


    @property
    def reason(self)  :
        """
        The recognition reason
        """
        return ResultReason(self._reason)


    __swig_getmethods__["offset"] = _speech_py_impl.RecognitionResult_offset
    if _newclass: offset = property(_speech_py_impl.RecognitionResult_offset)

    __swig_getmethods__["duration"] = _speech_py_impl.RecognitionResult_duration
    if _newclass: duration = property(_speech_py_impl.RecognitionResult_duration)

    @property
    def json(self)  :
        """The bare JSON representation of the result from the Speech Service."""
        return self.properties.get_property(PropertyId.SpeechServiceResponse_JsonResult)
    @property
    def error_json(self)  :
        """The bare JSON representation of the error from the Speech Service."""
        return self.properties.get_property(PropertyId.SpeechServiceResponse_JsonErrorDetails)
    @property
    def cancellation_details(self)  :
        """The reason why recognition was cancelled.

        Returns `None` if there was no cancellation."""
        if ResultReason.Canceled == self.reason:
            return CancellationDetails._from_result(self)
    @property
    def no_match_details(self)  :
        """Detailed information for NoMatch recognition results.

        Returns `None` if there was a match found."""
        if ResultReason.NoMatch == self.reason:
            return NoMatchDetails._from_result(self) 
RecognitionResult_swigregister = _speech_py_impl.RecognitionResult_swigregister
RecognitionResult_swigregister(RecognitionResult)

class CancellationDetails(_object):
    """

    Contains detailed information about why a result was canceled.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CancellationDetails, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CancellationDetails, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _from_result(result )  :
        """

        Creates an instance of CancellationDetails object for the canceled
        RecognitionResult.

        :param result: The result that was canceled.
        :return: A CancellationDetails instance.

        """
        return _speech_py_impl.CancellationDetails__from_result(result)

    _from_result = staticmethod(_from_result)
    __swig_getmethods__["_reason"] = _speech_py_impl.CancellationDetails__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.CancellationDetails__reason_get)
    __swig_getmethods__["error_code"] = _speech_py_impl.CancellationDetails_error_code_get
    if _newclass:
        error_code = _swig_property(_speech_py_impl.CancellationDetails_error_code_get)
    __swig_getmethods__["error_details"] = _speech_py_impl.CancellationDetails_error_details_get
    if _newclass:
        error_details = _swig_property(_speech_py_impl.CancellationDetails_error_details_get)

    def __str__(self):
        return u'{}(reason={}, error_details="{}")'.format(type(self).__name__,
            self.reason, self.error_details)


    @property
    def reason(self)  :
        """
        The reason the result was canceled.
        """
        return CancellationReason(self._reason)

    __swig_destroy__ = _speech_py_impl.delete_CancellationDetails
    __del__ = lambda self: None
CancellationDetails_swigregister = _speech_py_impl.CancellationDetails_swigregister
CancellationDetails_swigregister(CancellationDetails)

def CancellationDetails__from_result(result )  :
    """

    Creates an instance of CancellationDetails object for the canceled
    RecognitionResult.

    :param result: The result that was canceled.
    :return: A CancellationDetails instance.

    """
    return _speech_py_impl.CancellationDetails__from_result(result)

class NoMatchDetails(_object):
    """

    Detailed information for NoMatch recognition results.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoMatchDetails, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NoMatchDetails, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_result = staticmethod(_speech_py_impl.NoMatchDetails__from_result)
    else:
        _from_result = _speech_py_impl.NoMatchDetails__from_result
    __swig_getmethods__["_reason"] = _speech_py_impl.NoMatchDetails__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.NoMatchDetails__reason_get)

    def __str__(self):
        return u'{}(reason={})'.format(type(self).__name__, self.reason)


    @property
    def reason(self)  :
        """
        The reason for the NoMatch result
        """
        return NoMatchReason(self._reason)

    __swig_destroy__ = _speech_py_impl.delete_NoMatchDetails
    __del__ = lambda self: None
NoMatchDetails_swigregister = _speech_py_impl.NoMatchDetails_swigregister
NoMatchDetails_swigregister(NoMatchDetails)

def NoMatchDetails__from_result(result )  :
    return _speech_py_impl.NoMatchDetails__from_result(result)
NoMatchDetails__from_result = _speech_py_impl.NoMatchDetails__from_result

class RecognitionEventArgs(SessionEventArgs):
    """

    Provides data for the RecognitionEvent.

    """

    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionEventArgs
    __del__ = lambda self: None
    __swig_getmethods__["offset"] = _speech_py_impl.RecognitionEventArgs_offset_get
    if _newclass:
        offset = _swig_property(_speech_py_impl.RecognitionEventArgs_offset_get)
RecognitionEventArgs_swigregister = _speech_py_impl.RecognitionEventArgs_swigregister
RecognitionEventArgs_swigregister(RecognitionEventArgs)

class Participant(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Participant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Participant, name)
    __repr__ = _swig_repr
    if _newclass:
        _From = staticmethod(_speech_py_impl.Participant__From)
    else:
        _From = _speech_py_impl.Participant__From

    def __init__(self, *args):
        this = _speech_py_impl.new_Participant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Participant
    __del__ = lambda self: None
    __swig_getmethods__["id"] = _speech_py_impl.Participant_id_get
    if _newclass:
        id = _swig_property(_speech_py_impl.Participant_id_get)
    __swig_getmethods__["avatar"] = _speech_py_impl.Participant_avatar_get
    if _newclass:
        avatar = _swig_property(_speech_py_impl.Participant_avatar_get)
    __swig_getmethods__["display_name"] = _speech_py_impl.Participant_display_name_get
    if _newclass:
        display_name = _swig_property(_speech_py_impl.Participant_display_name_get)
    __swig_getmethods__["is_using_tts"] = _speech_py_impl.Participant_is_using_tts_get
    if _newclass:
        is_using_tts = _swig_property(_speech_py_impl.Participant_is_using_tts_get)
    __swig_getmethods__["is_muted"] = _speech_py_impl.Participant_is_muted_get
    if _newclass:
        is_muted = _swig_property(_speech_py_impl.Participant_is_muted_get)
    __swig_getmethods__["is_host"] = _speech_py_impl.Participant_is_host_get
    if _newclass:
        is_host = _swig_property(_speech_py_impl.Participant_is_host_get)

    def set_preferred_language(self, preferredLanguage )  :
        return _speech_py_impl.Participant_set_preferred_language(self, preferredLanguage)

    def set_voice_signature(self, voiceSignature )  :
        return _speech_py_impl.Participant_set_voice_signature(self, voiceSignature)
    __swig_getmethods__["properties"] = _speech_py_impl.Participant_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.Participant_properties_get)
Participant_swigregister = _speech_py_impl.Participant_swigregister
Participant_swigregister(Participant)

def Participant__From(*args)  :
    return _speech_py_impl.Participant__From(*args)
Participant__From = _speech_py_impl.Participant__From

class User(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, User, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, User, name)
    __repr__ = _swig_repr
    if _newclass:
        from_user_id = staticmethod(_speech_py_impl.User_from_user_id)
    else:
        from_user_id = _speech_py_impl.User_from_user_id

    def __init__(self, *args):
        this = _speech_py_impl.new_User(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_User
    __del__ = lambda self: None

    def get_id(self)  :
        return _speech_py_impl.User_get_id(self)
User_swigregister = _speech_py_impl.User_swigregister
User_swigregister(User)
MAX_USER_ID_LEN = cvar.MAX_USER_ID_LEN

def User_from_user_id(userId )  :
    return _speech_py_impl.User_from_user_id(userId)
User_from_user_id = _speech_py_impl.User_from_user_id

class SessionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SessionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SessionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SessionEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.SessionEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SessionEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SessionEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SessionEventSignal_connect(self, func, wrapped_type)

SessionEventSignal_swigregister = _speech_py_impl.SessionEventSignal_swigregister
SessionEventSignal_swigregister(SessionEventSignal)

class RecognitionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.RecognitionEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.RecognitionEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.RecognitionEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.RecognitionEventSignal_connect(self, func, wrapped_type)

RecognitionEventSignal_swigregister = _speech_py_impl.RecognitionEventSignal_swigregister
RecognitionEventSignal_swigregister(RecognitionEventSignal)

class ConnectionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ConnectionEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.ConnectionEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.ConnectionEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.ConnectionEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.ConnectionEventSignal_connect(self, func, wrapped_type)

ConnectionEventSignal_swigregister = _speech_py_impl.ConnectionEventSignal_swigregister
ConnectionEventSignal_swigregister(ConnectionEventSignal)

class Recognizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Recognizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Recognizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def is_enabled(self)  :
        return _speech_py_impl.Recognizer_is_enabled(self)

    def enable(self)  :
        return _speech_py_impl.Recognizer_enable(self)

    def disable(self)  :
        return _speech_py_impl.Recognizer_disable(self)
    __swig_destroy__ = _speech_py_impl.delete_Recognizer
    __del__ = lambda self: None

    __swig_getmethods__["is_enabled"] = _speech_py_impl.Recognizer_is_enabled
    if _newclass: is_enabled = property(_speech_py_impl.Recognizer_is_enabled)
Recognizer_swigregister = _speech_py_impl.Recognizer_swigregister
Recognizer_swigregister(Recognizer)

class BaseRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.BaseRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.BaseRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.BaseRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.BaseRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.BaseRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.BaseRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.BaseRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.BaseRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.BaseRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.BaseRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.BaseRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.BaseRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.BaseRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.BaseRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_BaseRecognizerBase
    __del__ = lambda self: None
BaseRecognizerBase_swigregister = _speech_py_impl.BaseRecognizerBase_swigregister
BaseRecognizerBase_swigregister(BaseRecognizerBase)

class BaseAsyncRecognizer(BaseRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [BaseRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseAsyncRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseAsyncRecognizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_BaseAsyncRecognizer
    __del__ = lambda self: None
BaseAsyncRecognizer_swigregister = _speech_py_impl.BaseAsyncRecognizer_swigregister
BaseAsyncRecognizer_swigregister(BaseAsyncRecognizer)

class SpeechRecognitionResult(RecognitionResult):
    """

    Base class for speech recognition results.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionResult
    __del__ = lambda self: None
SpeechRecognitionResult_swigregister = _speech_py_impl.SpeechRecognitionResult_swigregister
SpeechRecognitionResult_swigregister(SpeechRecognitionResult)

class SpeechRecognitionEventArgs(RecognitionEventArgs):
    """

    Class for speech recognition event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)  :
        return _speech_py_impl.SpeechRecognitionEventArgs__get_result(self)

    def __str__(self):
        return u'{}:(session_id={}, result={})'.format(type(self), self.session_id, self.result)


    @property
    def result(self)  :
        """
        Contains the speech recognition result.
        """
        return self._get_result()

SpeechRecognitionEventArgs_swigregister = _speech_py_impl.SpeechRecognitionEventArgs_swigregister
SpeechRecognitionEventArgs_swigregister(SpeechRecognitionEventArgs)

class SpeechRecognitionCanceledEventArgs(SpeechRecognitionEventArgs):
    """

    Class for speech recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [SpeechRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)  :
        return _speech_py_impl.SpeechRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)  :
        """
        Details about why speech recognition was canceled.
        """
        return self._get_cancellation_details()

SpeechRecognitionCanceledEventArgs_swigregister = _speech_py_impl.SpeechRecognitionCanceledEventArgs_swigregister
SpeechRecognitionCanceledEventArgs_swigregister(SpeechRecognitionCanceledEventArgs)

class AutoDetectSourceLanguageResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AutoDetectSourceLanguageResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AutoDetectSourceLanguageResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        from_result = staticmethod(_speech_py_impl.AutoDetectSourceLanguageResult_from_result)
    else:
        from_result = _speech_py_impl.AutoDetectSourceLanguageResult_from_result
    __swig_getmethods__["language"] = _speech_py_impl.AutoDetectSourceLanguageResult_language_get
    if _newclass:
        language = _swig_property(_speech_py_impl.AutoDetectSourceLanguageResult_language_get)
    __swig_destroy__ = _speech_py_impl.delete_AutoDetectSourceLanguageResult
    __del__ = lambda self: None
AutoDetectSourceLanguageResult_swigregister = _speech_py_impl.AutoDetectSourceLanguageResult_swigregister
AutoDetectSourceLanguageResult_swigregister(AutoDetectSourceLanguageResult)

def AutoDetectSourceLanguageResult_from_result(result )  :
    return _speech_py_impl.AutoDetectSourceLanguageResult_from_result(result)
AutoDetectSourceLanguageResult_from_result = _speech_py_impl.AutoDetectSourceLanguageResult_from_result

class SpeechRecognitionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.SpeechRecognitionEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_connect(self, func, wrapped_type)

SpeechRecognitionEventSignal_swigregister = _speech_py_impl.SpeechRecognitionEventSignal_swigregister
SpeechRecognitionEventSignal_swigregister(SpeechRecognitionEventSignal)

class SpeechRecognitionCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_connect(self, func, wrapped_type)

SpeechRecognitionCanceledEventSignal_swigregister = _speech_py_impl.SpeechRecognitionCanceledEventSignal_swigregister
SpeechRecognitionCanceledEventSignal_swigregister(SpeechRecognitionCanceledEventSignal)

class SpeechRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.SpeechRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.SpeechRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.SpeechRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.SpeechRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.SpeechRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.SpeechRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.SpeechRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.SpeechRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.SpeechRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.SpeechRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.SpeechRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.SpeechRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.SpeechRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.SpeechRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognizerBase
    __del__ = lambda self: None
SpeechRecognizerBase_swigregister = _speech_py_impl.SpeechRecognizerBase_swigregister
SpeechRecognizerBase_swigregister(SpeechRecognizerBase)

class SpeechRecognizer(SpeechRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [SpeechRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.SpeechRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.SpeechRecognizer__from_config

    def __init__(self, hreco ):
        this = _speech_py_impl.new_SpeechRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognizer
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.SpeechRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.SpeechRecognizer_properties_get)

    def get_endpoint_id(self)  :
        return _speech_py_impl.SpeechRecognizer_get_endpoint_id(self)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.SpeechRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.SpeechRecognizer_get_authorization_token(self)

    def recognize_once(self)  :
        return _speech_py_impl.SpeechRecognizer_recognize_once(self)

    def start_continuous_recognition(self)  :
        return _speech_py_impl.SpeechRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)  :
        return _speech_py_impl.SpeechRecognizer_stop_continuous_recognition(self)

    def start_keyword_recognition(self, model )  :
        return _speech_py_impl.SpeechRecognizer_start_keyword_recognition(self, model)

    def stop_keyword_recognition(self)  :
        return _speech_py_impl.SpeechRecognizer_stop_keyword_recognition(self)

    def recognize_once_async(self)  :
        return _speech_py_impl.SpeechRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)  :
        return _speech_py_impl.SpeechRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)  :
        return _speech_py_impl.SpeechRecognizer_stop_continuous_recognition_async(self)

    def start_keyword_recognition_async(self, model )  :
        return _speech_py_impl.SpeechRecognizer_start_keyword_recognition_async(self, model)

    def stop_keyword_recognition_async(self)  :
        return _speech_py_impl.SpeechRecognizer_stop_keyword_recognition_async(self)
SpeechRecognizer_swigregister = _speech_py_impl.SpeechRecognizer_swigregister
SpeechRecognizer_swigregister(SpeechRecognizer)

def SpeechRecognizer__from_config(*args)  :
    return _speech_py_impl.SpeechRecognizer__from_config(*args)
SpeechRecognizer__from_config = _speech_py_impl.SpeechRecognizer__from_config

class IntentRecognitionResult(RecognitionResult):
    """

    Represents the result of an intent recognition.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["intent_id"] = _speech_py_impl.IntentRecognitionResult_intent_id_get
    if _newclass:
        intent_id = _swig_property(_speech_py_impl.IntentRecognitionResult_intent_id_get)

    @property
    def intent_json(self)  :
        """The bare JSON representation of the result from the Language Understanding service."""
        return self.properties.get_property(PropertyId.LanguageUnderstandingServiceResponse_JsonResult)

IntentRecognitionResult_swigregister = _speech_py_impl.IntentRecognitionResult_swigregister
IntentRecognitionResult_swigregister(IntentRecognitionResult)

class IntentRecognitionEventArgs(RecognitionEventArgs):
    """

    Class for intent recognition event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)  :
        return _speech_py_impl.IntentRecognitionEventArgs__get_result(self)

    @property
    def result(self)  :
        """
        Contains the intent recognition result.
        """
        return self._get_result()

IntentRecognitionEventArgs_swigregister = _speech_py_impl.IntentRecognitionEventArgs_swigregister
IntentRecognitionEventArgs_swigregister(IntentRecognitionEventArgs)

class IntentRecognitionCanceledEventArgs(IntentRecognitionEventArgs):
    """

    Class for intent recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [IntentRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [IntentRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)  :
        return _speech_py_impl.IntentRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)  :
        """
        Details about why intent recognition was canceled.
        """
        return self._get_cancellation_details()

IntentRecognitionCanceledEventArgs_swigregister = _speech_py_impl.IntentRecognitionCanceledEventArgs_swigregister
IntentRecognitionCanceledEventArgs_swigregister(IntentRecognitionCanceledEventArgs)

class LanguageUnderstandingModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LanguageUnderstandingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LanguageUnderstandingModel, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.LanguageUnderstandingModel__from_endpoint
    if _newclass:
        _from_app_id = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_app_id)
    else:
        _from_app_id = _speech_py_impl.LanguageUnderstandingModel__from_app_id
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_subscription)
    else:
        _from_subscription = _speech_py_impl.LanguageUnderstandingModel__from_subscription

    def __init__(self, *args):
        this = _speech_py_impl.new_LanguageUnderstandingModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_LanguageUnderstandingModel
    __del__ = lambda self: None
LanguageUnderstandingModel_swigregister = _speech_py_impl.LanguageUnderstandingModel_swigregister
LanguageUnderstandingModel_swigregister(LanguageUnderstandingModel)

def LanguageUnderstandingModel__from_endpoint(uri )  :
    return _speech_py_impl.LanguageUnderstandingModel__from_endpoint(uri)
LanguageUnderstandingModel__from_endpoint = _speech_py_impl.LanguageUnderstandingModel__from_endpoint

def LanguageUnderstandingModel__from_app_id(appId )  :
    return _speech_py_impl.LanguageUnderstandingModel__from_app_id(appId)
LanguageUnderstandingModel__from_app_id = _speech_py_impl.LanguageUnderstandingModel__from_app_id

def LanguageUnderstandingModel__from_subscription(subscriptionKey , appId , region )  :
    return _speech_py_impl.LanguageUnderstandingModel__from_subscription(subscriptionKey, appId, region)
LanguageUnderstandingModel__from_subscription = _speech_py_impl.LanguageUnderstandingModel__from_subscription

class IntentTrigger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentTrigger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentTrigger, name)
    __repr__ = _swig_repr
    if _newclass:
        _From = staticmethod(_speech_py_impl.IntentTrigger__From)
    else:
        _From = _speech_py_impl.IntentTrigger__From
    __swig_destroy__ = _speech_py_impl.delete_IntentTrigger
    __del__ = lambda self: None

    def __init__(self, htrigger ):
        this = _speech_py_impl.new_IntentTrigger(htrigger)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
IntentTrigger_swigregister = _speech_py_impl.IntentTrigger_swigregister
IntentTrigger_swigregister(IntentTrigger)

def IntentTrigger__From(*args)  :
    return _speech_py_impl.IntentTrigger__From(*args)
IntentTrigger__From = _speech_py_impl.IntentTrigger__From

class IntentEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.IntentEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.IntentEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.IntentEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.IntentEventSignal_connect(self, func, wrapped_type)

IntentEventSignal_swigregister = _speech_py_impl.IntentEventSignal_swigregister
IntentEventSignal_swigregister(IntentEventSignal)

class IntentCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.IntentCanceledEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.IntentCanceledEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.IntentCanceledEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.IntentCanceledEventSignal_connect(self, func, wrapped_type)

IntentCanceledEventSignal_swigregister = _speech_py_impl.IntentCanceledEventSignal_swigregister
IntentCanceledEventSignal_swigregister(IntentCanceledEventSignal)

class IntentRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.IntentRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.IntentRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.IntentRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.IntentRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.IntentRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.IntentRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.IntentRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.IntentRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.IntentRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.IntentRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.IntentRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.IntentRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.IntentRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.IntentRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognizerBase
    __del__ = lambda self: None
IntentRecognizerBase_swigregister = _speech_py_impl.IntentRecognizerBase_swigregister
IntentRecognizerBase_swigregister(IntentRecognizerBase)

class ConversationTranscriptionResult(RecognitionResult):
    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriptionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriptionResult, name)
    __repr__ = _swig_repr

    def __init__(self, hresult ):
        this = _speech_py_impl.new_ConversationTranscriptionResult(hresult)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriptionResult
    __del__ = lambda self: None
    __swig_getmethods__["user_id"] = _speech_py_impl.ConversationTranscriptionResult_user_id_get
    if _newclass:
        user_id = _swig_property(_speech_py_impl.ConversationTranscriptionResult_user_id_get)
ConversationTranscriptionResult_swigregister = _speech_py_impl.ConversationTranscriptionResult_swigregister
ConversationTranscriptionResult_swigregister(ConversationTranscriptionResult)

class ConversationTranscriptionEventArgs(RecognitionEventArgs):
    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriptionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriptionEventArgs, name)
    __repr__ = _swig_repr

    def __init__(self, hevent ):
        this = _speech_py_impl.new_ConversationTranscriptionEventArgs(hevent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriptionEventArgs
    __del__ = lambda self: None

    def _get_result(self)  :
        return _speech_py_impl.ConversationTranscriptionEventArgs__get_result(self)
ConversationTranscriptionEventArgs_swigregister = _speech_py_impl.ConversationTranscriptionEventArgs_swigregister
ConversationTranscriptionEventArgs_swigregister(ConversationTranscriptionEventArgs)

class ConversationTranscriptionCanceledEventArgs(ConversationTranscriptionEventArgs):
    __swig_setmethods__ = {}
    for _s in [ConversationTranscriptionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriptionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [ConversationTranscriptionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriptionCanceledEventArgs, name)
    __repr__ = _swig_repr

    def __init__(self, hevent ):
        this = _speech_py_impl.new_ConversationTranscriptionCanceledEventArgs(hevent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriptionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)  :
        return _speech_py_impl.ConversationTranscriptionCanceledEventArgs__get_cancellation_details(self)
ConversationTranscriptionCanceledEventArgs_swigregister = _speech_py_impl.ConversationTranscriptionCanceledEventArgs_swigregister
ConversationTranscriptionCanceledEventArgs_swigregister(ConversationTranscriptionCanceledEventArgs)

class ConversationTranscriberEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriberEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriberEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriberEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.ConversationTranscriberEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.ConversationTranscriberEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.ConversationTranscriberEventSignal_is_connected(self)

ConversationTranscriberEventSignal_swigregister = _speech_py_impl.ConversationTranscriberEventSignal_swigregister
ConversationTranscriberEventSignal_swigregister(ConversationTranscriberEventSignal)

class ConversationTranscriberCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriberCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriberCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriberCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.ConversationTranscriberCanceledEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.ConversationTranscriberCanceledEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.ConversationTranscriberCanceledEventSignal_is_connected(self)

ConversationTranscriberCanceledEventSignal_swigregister = _speech_py_impl.ConversationTranscriberCanceledEventSignal_swigregister
ConversationTranscriberCanceledEventSignal_swigregister(ConversationTranscriberCanceledEventSignal)

class ConversationTranscriberRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriberRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriberRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.ConversationTranscriberRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.ConversationTranscriberRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.ConversationTranscriberRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.ConversationTranscriberRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.ConversationTranscriberRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.ConversationTranscriberRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.ConversationTranscriberRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.ConversationTranscriberRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriberRecognizerBase
    __del__ = lambda self: None
ConversationTranscriberRecognizerBase_swigregister = _speech_py_impl.ConversationTranscriberRecognizerBase_swigregister
ConversationTranscriberRecognizerBase_swigregister(ConversationTranscriberRecognizerBase)

class IntentRecognizer(IntentRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [IntentRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [IntentRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.IntentRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.IntentRecognizer__from_config

    def __init__(self, hreco ):
        this = _speech_py_impl.new_IntentRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognizer
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.IntentRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.IntentRecognizer_properties_get)

    def add_all_intents(self, *args)  :
        return _speech_py_impl.IntentRecognizer_add_all_intents(self, *args)

    def add_intent(self, *args)  :
        return _speech_py_impl.IntentRecognizer_add_intent(self, *args)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.IntentRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.IntentRecognizer_get_authorization_token(self)

    def recognize_once(self)  :
        return _speech_py_impl.IntentRecognizer_recognize_once(self)

    def start_continuous_recognition(self)  :
        return _speech_py_impl.IntentRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)  :
        return _speech_py_impl.IntentRecognizer_stop_continuous_recognition(self)

    def start_keyword_recognition(self, model )  :
        return _speech_py_impl.IntentRecognizer_start_keyword_recognition(self, model)

    def stop_keyword_recognition(self)  :
        return _speech_py_impl.IntentRecognizer_stop_keyword_recognition(self)

    def recognize_once_async(self)  :
        return _speech_py_impl.IntentRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)  :
        return _speech_py_impl.IntentRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)  :
        return _speech_py_impl.IntentRecognizer_stop_continuous_recognition_async(self)

    def start_keyword_recognition_async(self, model )  :
        return _speech_py_impl.IntentRecognizer_start_keyword_recognition_async(self, model)

    def stop_keyword_recognition_async(self)  :
        return _speech_py_impl.IntentRecognizer_stop_keyword_recognition_async(self)
IntentRecognizer_swigregister = _speech_py_impl.IntentRecognizer_swigregister
IntentRecognizer_swigregister(IntentRecognizer)

def IntentRecognizer__from_config(speechConfig , audioInput =0)  :
    return _speech_py_impl.IntentRecognizer__from_config(speechConfig, audioInput)
IntentRecognizer__from_config = _speech_py_impl.IntentRecognizer__from_config

class ConversationTranscriber(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConversationTranscriber, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConversationTranscriber, name)
    __repr__ = _swig_repr
    if _newclass:
        from_config = staticmethod(_speech_py_impl.ConversationTranscriber_from_config)
    else:
        from_config = _speech_py_impl.ConversationTranscriber_from_config

    def __init__(self, hreco ):
        this = _speech_py_impl.new_ConversationTranscriber(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConversationTranscriber
    __del__ = lambda self: None
    __swig_getmethods__["session_started"] = _speech_py_impl.ConversationTranscriber_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.ConversationTranscriber_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.ConversationTranscriber_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.ConversationTranscriber_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.ConversationTranscriber_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.ConversationTranscriber_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.ConversationTranscriber_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.ConversationTranscriber_speech_end_detected_get)
    __swig_getmethods__["transcribing"] = _speech_py_impl.ConversationTranscriber_transcribing_get
    if _newclass:
        transcribing = _swig_property(_speech_py_impl.ConversationTranscriber_transcribing_get)
    __swig_getmethods__["transcribed"] = _speech_py_impl.ConversationTranscriber_transcribed_get
    if _newclass:
        transcribed = _swig_property(_speech_py_impl.ConversationTranscriber_transcribed_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.ConversationTranscriber_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.ConversationTranscriber_canceled_get)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.ConversationTranscriber_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.ConversationTranscriber_get_authorization_token(self)
    __swig_getmethods__["properties"] = _speech_py_impl.ConversationTranscriber_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.ConversationTranscriber_properties_get)

    def join_conversation_async(self, conversation )  :
        return _speech_py_impl.ConversationTranscriber_join_conversation_async(self, conversation)

    def leave_conversation_async(self)  :
        return _speech_py_impl.ConversationTranscriber_leave_conversation_async(self)

    def start_transcribing_async(self)  :
        return _speech_py_impl.ConversationTranscriber_start_transcribing_async(self)

    def stop_transcribing_async(self)  :
        return _speech_py_impl.ConversationTranscriber_stop_transcribing_async(self)
ConversationTranscriber_swigregister = _speech_py_impl.ConversationTranscriber_swigregister
ConversationTranscriber_swigregister(ConversationTranscriber)

def ConversationTranscriber_from_config(audioInput =0)  :
    return _speech_py_impl.ConversationTranscriber_from_config(audioInput)
ConversationTranscriber_from_config = _speech_py_impl.ConversationTranscriber_from_config

class Conversation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Conversation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Conversation, name)
    __repr__ = _swig_repr
    max_conversation_id_len = _speech_py_impl.Conversation_max_conversation_id_len

    def __init__(self, hconversation ):
        this = _speech_py_impl.new_Conversation(hconversation)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Conversation
    __del__ = lambda self: None

    def get_conversation_id(self)  :
        return _speech_py_impl.Conversation_get_conversation_id(self)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.Conversation_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.Conversation_get_authorization_token(self)
    __swig_getmethods__["properties"] = _speech_py_impl.Conversation_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.Conversation_properties_get)
    if _newclass:
        create_conversation_async = staticmethod(_speech_py_impl.Conversation_create_conversation_async)
    else:
        create_conversation_async = _speech_py_impl.Conversation_create_conversation_async

    def add_participant_async(self, *args)  :
        return _speech_py_impl.Conversation_add_participant_async(self, *args)

    def remove_participant_async(self, *args)  :
        return _speech_py_impl.Conversation_remove_participant_async(self, *args)

    def end_conversation_async(self)  :
        return _speech_py_impl.Conversation_end_conversation_async(self)

    def start_conversation_async(self)  :
        return _speech_py_impl.Conversation_start_conversation_async(self)

    def delete_conversation_async(self)  :
        return _speech_py_impl.Conversation_delete_conversation_async(self)

    def lock_conversation_async(self)  :
        return _speech_py_impl.Conversation_lock_conversation_async(self)

    def unlock_conversation_async(self)  :
        return _speech_py_impl.Conversation_unlock_conversation_async(self)

    def mute_all_participants_async(self)  :
        return _speech_py_impl.Conversation_mute_all_participants_async(self)

    def unmute_all_participants_async(self)  :
        return _speech_py_impl.Conversation_unmute_all_participants_async(self)

    def mute_participant_async(self, participantId )  :
        return _speech_py_impl.Conversation_mute_participant_async(self, participantId)

    def unmute_participant_async(self, participantId )  :
        return _speech_py_impl.Conversation_unmute_participant_async(self, participantId)
Conversation_swigregister = _speech_py_impl.Conversation_swigregister
Conversation_swigregister(Conversation)

def Conversation_create_conversation_async(speechConfig , conversationId )  :
    return _speech_py_impl.Conversation_create_conversation_async(speechConfig, conversationId)
Conversation_create_conversation_async = _speech_py_impl.Conversation_create_conversation_async

class TranslationRecognitionResult(RecognitionResult):
    """

    Defines the translation text result.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["translations"] = _speech_py_impl.TranslationRecognitionResult_translations_get
    if _newclass:
        translations = _swig_property(_speech_py_impl.TranslationRecognitionResult_translations_get)
TranslationRecognitionResult_swigregister = _speech_py_impl.TranslationRecognitionResult_swigregister
TranslationRecognitionResult_swigregister(TranslationRecognitionResult)

class TranslationSynthesisResult(_object):
    """

    Defines the translation synthesis result, i.e. the voice output of the translated text in the target language.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisResult
    __del__ = lambda self: None
    __swig_getmethods__["_reason"] = _speech_py_impl.TranslationSynthesisResult__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.TranslationSynthesisResult__reason_get)
    __swig_getmethods__["_audio"] = _speech_py_impl.TranslationSynthesisResult__audio_get
    if _newclass:
        _audio = _swig_property(_speech_py_impl.TranslationSynthesisResult__audio_get)

    @property
    def audio(self)  :
        """The synthesized translation result as a `bytes` object"""
        return bytes(_speech_py_impl.TranslationSynthesisResult__audio_get(self))

    @property
    def reason(self)  :
        """
        The reason for the result
        """
        return ResultReason(self._reason)

TranslationSynthesisResult_swigregister = _speech_py_impl.TranslationSynthesisResult_swigregister
TranslationSynthesisResult_swigregister(TranslationSynthesisResult)

class TranslationRecognitionEventArgs(RecognitionEventArgs):
    """

    Defines payload that is sent with the event Recognizing or Recognized.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)  :
        return _speech_py_impl.TranslationRecognitionEventArgs__get_result(self)

    @property
    def result(self)  :
        """
        Contains the translation recognition result.
        """
        return self._get_result()

TranslationRecognitionEventArgs_swigregister = _speech_py_impl.TranslationRecognitionEventArgs_swigregister
TranslationRecognitionEventArgs_swigregister(TranslationRecognitionEventArgs)

class TranslationRecognitionCanceledEventArgs(TranslationRecognitionEventArgs):
    """

    Class for translation recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [TranslationRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [TranslationRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)  :
        return _speech_py_impl.TranslationRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)  :
        """
        Details about why translation was canceled.
        """
        return self._get_cancellation_details()

TranslationRecognitionCanceledEventArgs_swigregister = _speech_py_impl.TranslationRecognitionCanceledEventArgs_swigregister
TranslationRecognitionCanceledEventArgs_swigregister(TranslationRecognitionCanceledEventArgs)

class TranslationSynthesisEventArgs(SessionEventArgs):
    """

    Defines payload that is sent with the event :py:obj:`TranslationRecognizer.synthesizing`.

    """

    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisEventArgs
    __del__ = lambda self: None

    def _get_result(self)  :
        return _speech_py_impl.TranslationSynthesisEventArgs__get_result(self)

    @property
    def result(self)  :
        """
        Contains the translation synthesis result.
        """
        return self._get_result()

TranslationSynthesisEventArgs_swigregister = _speech_py_impl.TranslationSynthesisEventArgs_swigregister
TranslationSynthesisEventArgs_swigregister(TranslationSynthesisEventArgs)

class TranslationTextEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationTextEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationTextEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationTextEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.TranslationTextEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationTextEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationTextEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationTextEventSignal_connect(self, func, wrapped_type)

TranslationTextEventSignal_swigregister = _speech_py_impl.TranslationTextEventSignal_swigregister
TranslationTextEventSignal_swigregister(TranslationTextEventSignal)

class TranslationTextCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationTextCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationTextCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationTextCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.TranslationTextCanceledEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_connect(self, func, wrapped_type)

TranslationTextCanceledEventSignal_swigregister = _speech_py_impl.TranslationTextCanceledEventSignal_swigregister
TranslationTextCanceledEventSignal_swigregister(TranslationTextCanceledEventSignal)

class TranslationSynthesisEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.TranslationSynthesisEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_connect(self, func, wrapped_type)

TranslationSynthesisEventSignal_swigregister = _speech_py_impl.TranslationSynthesisEventSignal_swigregister
TranslationSynthesisEventSignal_swigregister(TranslationSynthesisEventSignal)

class TranslationRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.TranslationRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.TranslationRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.TranslationRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.TranslationRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.TranslationRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.TranslationRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.TranslationRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.TranslationRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.TranslationRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.TranslationRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.TranslationRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.TranslationRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.TranslationRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.TranslationRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognizerBase
    __del__ = lambda self: None
TranslationRecognizerBase_swigregister = _speech_py_impl.TranslationRecognizerBase_swigregister
TranslationRecognizerBase_swigregister(TranslationRecognizerBase)

class ActivityReceivedEventArgs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ActivityReceivedEventArgs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ActivityReceivedEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ActivityReceivedEventArgs
    __del__ = lambda self: None

    def get_activity(self)  :
        return _speech_py_impl.ActivityReceivedEventArgs_get_activity(self)

    def get_audio(self)  :
        return _speech_py_impl.ActivityReceivedEventArgs_get_audio(self)

    def has_audio(self)  :
        return _speech_py_impl.ActivityReceivedEventArgs_has_audio(self)
ActivityReceivedEventArgs_swigregister = _speech_py_impl.ActivityReceivedEventArgs_swigregister
ActivityReceivedEventArgs_swigregister(ActivityReceivedEventArgs)

class ActivityReceivedEventListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ActivityReceivedEventListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ActivityReceivedEventListener, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, eventArgs )  :
        return _speech_py_impl.ActivityReceivedEventListener___call__(self, eventArgs)
    __swig_destroy__ = _speech_py_impl.delete_ActivityReceivedEventListener
    __del__ = lambda self: None
ActivityReceivedEventListener_swigregister = _speech_py_impl.ActivityReceivedEventListener_swigregister
ActivityReceivedEventListener_swigregister(ActivityReceivedEventListener)

class ActivityReceivedEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ActivityReceivedEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ActivityReceivedEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ActivityReceivedEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.ActivityReceivedEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.ActivityReceivedEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.ActivityReceivedEventSignal_is_connected(self)

ActivityReceivedEventSignal_swigregister = _speech_py_impl.ActivityReceivedEventSignal_swigregister
ActivityReceivedEventSignal_swigregister(ActivityReceivedEventSignal)

AUDIO_OUTPUT_BUFFER_SIZE = _speech_py_impl.AUDIO_OUTPUT_BUFFER_SIZE
class SpeechSynthesisResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get_audio_length(self)  :
        return _speech_py_impl.SpeechSynthesisResult_get_audio_length(self)

    def _get_audio_data(self)  :
        return _speech_py_impl.SpeechSynthesisResult__get_audio_data(self)
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisResult
    __del__ = lambda self: None
    __swig_getmethods__["result_id"] = _speech_py_impl.SpeechSynthesisResult_result_id_get
    if _newclass:
        result_id = _swig_property(_speech_py_impl.SpeechSynthesisResult_result_id_get)
    __swig_getmethods__["_reason"] = _speech_py_impl.SpeechSynthesisResult__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.SpeechSynthesisResult__reason_get)
    __swig_getmethods__["properties"] = _speech_py_impl.SpeechSynthesisResult_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.SpeechSynthesisResult_properties_get)

    def __str__(self):
        return u'{}:(result_id={})'.format(type(self), self.result_id)


    @property
    def audio_data(self)  :
        """The synthesized TTS result as a `bytes` object"""
        audio_length = _speech_py_impl.SpeechSynthesisResult_get_audio_length(self)
        if audio_length > 0:
            return bytes(_speech_py_impl.SpeechSynthesisResult__get_audio_data(self))
        else:
            return bytes(0)


    @property
    def reason(self)  :
        """
        The speech synthesis reason
        """
        return ResultReason(self._reason)


    @property
    def cancellation_details(self)  :
        """The reason why speech synthesis was cancelled.

        Returns `None` if there was no cancellation."""
        if ResultReason.Canceled == self.reason:
            return SpeechSynthesisCancellationDetails._from_result(self) 
SpeechSynthesisResult_swigregister = _speech_py_impl.SpeechSynthesisResult_swigregister
SpeechSynthesisResult_swigregister(SpeechSynthesisResult)

class AudioDataStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioDataStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioDataStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_result = staticmethod(_speech_py_impl.AudioDataStream__from_result)
    else:
        _from_result = _speech_py_impl.AudioDataStream__from_result

    def get_status(self)  :
        return _speech_py_impl.AudioDataStream_get_status(self)

    def can_read_data(self, bytesRequested )  :
        return _speech_py_impl.AudioDataStream_can_read_data(self, bytesRequested)

    def read_data(self, buffer )  :
        return _speech_py_impl.AudioDataStream_read_data(self, buffer)

    def save_to_wav_file(self, fileName )  :
        return _speech_py_impl.AudioDataStream_save_to_wav_file(self, fileName)

    def get_position(self)  :
        return _speech_py_impl.AudioDataStream_get_position(self)

    def set_position(self, pos )  :
        return _speech_py_impl.AudioDataStream_set_position(self, pos)
    __swig_getmethods__["properties"] = _speech_py_impl.AudioDataStream_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.AudioDataStream_properties_get)

    def save_to_wav_file_async(self, fileName )  :
        return _speech_py_impl.AudioDataStream_save_to_wav_file_async(self, fileName)

    @property
    def status(self)  :
        """
        The audio data stream status
        """
        return StreamStatus(self.get_status())

    __swig_destroy__ = _speech_py_impl.delete_AudioDataStream
    __del__ = lambda self: None
AudioDataStream_swigregister = _speech_py_impl.AudioDataStream_swigregister
AudioDataStream_swigregister(AudioDataStream)

def AudioDataStream__from_result(result )  :
    return _speech_py_impl.AudioDataStream__from_result(result)
AudioDataStream__from_result = _speech_py_impl.AudioDataStream__from_result

class SpeechSynthesisCancellationDetails(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisCancellationDetails, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisCancellationDetails, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_result = staticmethod(_speech_py_impl.SpeechSynthesisCancellationDetails__from_result)
    else:
        _from_result = _speech_py_impl.SpeechSynthesisCancellationDetails__from_result
    if _newclass:
        _from_stream = staticmethod(_speech_py_impl.SpeechSynthesisCancellationDetails__from_stream)
    else:
        _from_stream = _speech_py_impl.SpeechSynthesisCancellationDetails__from_stream
    __swig_getmethods__["_reason"] = _speech_py_impl.SpeechSynthesisCancellationDetails__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.SpeechSynthesisCancellationDetails__reason_get)
    __swig_getmethods__["error_code"] = _speech_py_impl.SpeechSynthesisCancellationDetails_error_code_get
    if _newclass:
        error_code = _swig_property(_speech_py_impl.SpeechSynthesisCancellationDetails_error_code_get)
    __swig_getmethods__["error_details"] = _speech_py_impl.SpeechSynthesisCancellationDetails_error_details_get
    if _newclass:
        error_details = _swig_property(_speech_py_impl.SpeechSynthesisCancellationDetails_error_details_get)

    def __str__(self):
        return u'{}(reason={}, error_details="{}")'.format(type(self).__name__,
            self.reason, self.error_details)


    @property
    def reason(self)  :
        """
        The reason the synthesis was canceled
        """
        return CancellationReason(self._reason)

    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisCancellationDetails
    __del__ = lambda self: None
SpeechSynthesisCancellationDetails_swigregister = _speech_py_impl.SpeechSynthesisCancellationDetails_swigregister
SpeechSynthesisCancellationDetails_swigregister(SpeechSynthesisCancellationDetails)

def SpeechSynthesisCancellationDetails__from_result(result )  :
    return _speech_py_impl.SpeechSynthesisCancellationDetails__from_result(result)
SpeechSynthesisCancellationDetails__from_result = _speech_py_impl.SpeechSynthesisCancellationDetails__from_result

def SpeechSynthesisCancellationDetails__from_stream(stream )  :
    return _speech_py_impl.SpeechSynthesisCancellationDetails__from_stream(stream)
SpeechSynthesisCancellationDetails__from_stream = _speech_py_impl.SpeechSynthesisCancellationDetails__from_stream

class SpeechSynthesisEventArgs(EventArgs):
    __swig_setmethods__ = {}
    for _s in [EventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisEventArgs
    __del__ = lambda self: None
    __swig_setmethods__["result"] = _speech_py_impl.SpeechSynthesisEventArgs_result_set
    __swig_getmethods__["result"] = _speech_py_impl.SpeechSynthesisEventArgs_result_get
    if _newclass:
        result = _swig_property(_speech_py_impl.SpeechSynthesisEventArgs_result_get, _speech_py_impl.SpeechSynthesisEventArgs_result_set)
SpeechSynthesisEventArgs_swigregister = _speech_py_impl.SpeechSynthesisEventArgs_swigregister
SpeechSynthesisEventArgs_swigregister(SpeechSynthesisEventArgs)

class SpeechSynthesisWordBoundaryEventArgs(EventArgs):
    __swig_setmethods__ = {}
    for _s in [EventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisWordBoundaryEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisWordBoundaryEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisWordBoundaryEventArgs
    __del__ = lambda self: None
    __swig_setmethods__["audio_offset"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_audio_offset_set
    __swig_getmethods__["audio_offset"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_audio_offset_get
    if _newclass:
        audio_offset = _swig_property(_speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_audio_offset_get, _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_audio_offset_set)
    __swig_setmethods__["text_offset"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_text_offset_set
    __swig_getmethods__["text_offset"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_text_offset_get
    if _newclass:
        text_offset = _swig_property(_speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_text_offset_get, _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_text_offset_set)
    __swig_setmethods__["word_length"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_word_length_set
    __swig_getmethods__["word_length"] = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_word_length_get
    if _newclass:
        word_length = _swig_property(_speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_word_length_get, _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_word_length_set)
SpeechSynthesisWordBoundaryEventArgs_swigregister = _speech_py_impl.SpeechSynthesisWordBoundaryEventArgs_swigregister
SpeechSynthesisWordBoundaryEventArgs_swigregister(SpeechSynthesisWordBoundaryEventArgs)

class SpeechSynthesisEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.SpeechSynthesisEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechSynthesisEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechSynthesisEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechSynthesisEventSignal_connect(self, func, wrapped_type)

SpeechSynthesisEventSignal_swigregister = _speech_py_impl.SpeechSynthesisEventSignal_swigregister
SpeechSynthesisEventSignal_swigregister(SpeechSynthesisEventSignal)

class SpeechSynthesisWordBoundaryEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesisWordBoundaryEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesisWordBoundaryEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesisWordBoundaryEventSignal
    __del__ = lambda self: None

    def __call__(self, t )  :
        return _speech_py_impl.SpeechSynthesisWordBoundaryEventSignal___call__(self, t)

    def disconnect_all(self)  :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechSynthesisWordBoundaryEventSignal_disconnect_all(self)


    def is_connected(self)  :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechSynthesisWordBoundaryEventSignal_is_connected(self)


    def connect(self, func , wrapped_type )  :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechSynthesisWordBoundaryEventSignal_connect(self, func, wrapped_type)

SpeechSynthesisWordBoundaryEventSignal_swigregister = _speech_py_impl.SpeechSynthesisWordBoundaryEventSignal_swigregister
SpeechSynthesisWordBoundaryEventSignal_swigregister(SpeechSynthesisWordBoundaryEventSignal)

class SpeechSynthesizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechSynthesizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechSynthesizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.SpeechSynthesizer__from_config)
    else:
        _from_config = _speech_py_impl.SpeechSynthesizer__from_config

    def speak_text(self, text )  :
        return _speech_py_impl.SpeechSynthesizer_speak_text(self, text)

    def speak_ssml(self, ssml )  :
        return _speech_py_impl.SpeechSynthesizer_speak_ssml(self, ssml)

    def start_speaking_text(self, text )  :
        return _speech_py_impl.SpeechSynthesizer_start_speaking_text(self, text)

    def start_speaking_ssml(self, ssml )  :
        return _speech_py_impl.SpeechSynthesizer_start_speaking_ssml(self, ssml)

    def set_authorization_token(self, token )  :
        return _speech_py_impl.SpeechSynthesizer_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.SpeechSynthesizer_get_authorization_token(self)
    __swig_destroy__ = _speech_py_impl.delete_SpeechSynthesizer
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.SpeechSynthesizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.SpeechSynthesizer_properties_get)
    __swig_getmethods__["synthesis_started"] = _speech_py_impl.SpeechSynthesizer_synthesis_started_get
    if _newclass:
        synthesis_started = _swig_property(_speech_py_impl.SpeechSynthesizer_synthesis_started_get)
    __swig_getmethods__["synthesizing"] = _speech_py_impl.SpeechSynthesizer_synthesizing_get
    if _newclass:
        synthesizing = _swig_property(_speech_py_impl.SpeechSynthesizer_synthesizing_get)
    __swig_getmethods__["synthesis_completed"] = _speech_py_impl.SpeechSynthesizer_synthesis_completed_get
    if _newclass:
        synthesis_completed = _swig_property(_speech_py_impl.SpeechSynthesizer_synthesis_completed_get)
    __swig_getmethods__["synthesis_canceled"] = _speech_py_impl.SpeechSynthesizer_synthesis_canceled_get
    if _newclass:
        synthesis_canceled = _swig_property(_speech_py_impl.SpeechSynthesizer_synthesis_canceled_get)
    __swig_getmethods__["word_boundary"] = _speech_py_impl.SpeechSynthesizer_word_boundary_get
    if _newclass:
        word_boundary = _swig_property(_speech_py_impl.SpeechSynthesizer_word_boundary_get)

    def speak_text_async(self, text )  :
        return _speech_py_impl.SpeechSynthesizer_speak_text_async(self, text)

    def speak_ssml_async(self, ssml )  :
        return _speech_py_impl.SpeechSynthesizer_speak_ssml_async(self, ssml)

    def start_speaking_text_async(self, text )  :
        return _speech_py_impl.SpeechSynthesizer_start_speaking_text_async(self, text)

    def start_speaking_ssml_async(self, ssml )  :
        return _speech_py_impl.SpeechSynthesizer_start_speaking_ssml_async(self, ssml)
SpeechSynthesizer_swigregister = _speech_py_impl.SpeechSynthesizer_swigregister
SpeechSynthesizer_swigregister(SpeechSynthesizer)

def SpeechSynthesizer__from_config(*args)  :
    return _speech_py_impl.SpeechSynthesizer__from_config(*args)
SpeechSynthesizer__from_config = _speech_py_impl.SpeechSynthesizer__from_config

class TranslationRecognizer(TranslationRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [TranslationRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [TranslationRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.TranslationRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.TranslationRecognizer__from_config

    def __init__(self, hreco ):
        this = _speech_py_impl.new_TranslationRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognizer
    __del__ = lambda self: None

    def set_authorization_token(self, token )  :
        return _speech_py_impl.TranslationRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.TranslationRecognizer_get_authorization_token(self)

    def add_target_language(self, language )  :
        return _speech_py_impl.TranslationRecognizer_add_target_language(self, language)

    def remove_target_language(self, language )  :
        return _speech_py_impl.TranslationRecognizer_remove_target_language(self, language)

    def get_target_languages(self)  :
        return _speech_py_impl.TranslationRecognizer_get_target_languages(self)
    __swig_getmethods__["properties"] = _speech_py_impl.TranslationRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.TranslationRecognizer_properties_get)
    __swig_getmethods__["synthesizing"] = _speech_py_impl.TranslationRecognizer_synthesizing_get
    if _newclass:
        synthesizing = _swig_property(_speech_py_impl.TranslationRecognizer_synthesizing_get)

    def recognize_once(self)  :
        return _speech_py_impl.TranslationRecognizer_recognize_once(self)

    def start_continuous_recognition(self)  :
        return _speech_py_impl.TranslationRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)  :
        return _speech_py_impl.TranslationRecognizer_stop_continuous_recognition(self)

    def start_keyword_recognition(self, model )  :
        return _speech_py_impl.TranslationRecognizer_start_keyword_recognition(self, model)

    def stop_keyword_recognition(self)  :
        return _speech_py_impl.TranslationRecognizer_stop_keyword_recognition(self)

    def recognize_once_async(self)  :
        return _speech_py_impl.TranslationRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)  :
        return _speech_py_impl.TranslationRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)  :
        return _speech_py_impl.TranslationRecognizer_stop_continuous_recognition_async(self)

    def start_keyword_recognition_async(self, model )  :
        return _speech_py_impl.TranslationRecognizer_start_keyword_recognition_async(self, model)

    def stop_keyword_recognition_async(self)  :
        return _speech_py_impl.TranslationRecognizer_stop_keyword_recognition_async(self)
TranslationRecognizer_swigregister = _speech_py_impl.TranslationRecognizer_swigregister
TranslationRecognizer_swigregister(TranslationRecognizer)

def TranslationRecognizer__from_config(speechconfig , audioInput =0)  :
    return _speech_py_impl.TranslationRecognizer__from_config(speechconfig, audioInput)
TranslationRecognizer__from_config = _speech_py_impl.TranslationRecognizer__from_config

class DialogServiceConnector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogServiceConnector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialogServiceConnector, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_DialogServiceConnector
    __del__ = lambda self: None
    if _newclass:
        from_config = staticmethod(_speech_py_impl.DialogServiceConnector_from_config)
    else:
        from_config = _speech_py_impl.DialogServiceConnector_from_config

    def set_authorization_token(self, token )  :
        return _speech_py_impl.DialogServiceConnector_set_authorization_token(self, token)

    def get_authorization_token(self)  :
        return _speech_py_impl.DialogServiceConnector_get_authorization_token(self)
    __swig_getmethods__["recognized"] = _speech_py_impl.DialogServiceConnector_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.DialogServiceConnector_recognized_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.DialogServiceConnector_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.DialogServiceConnector_recognizing_get)
    __swig_getmethods__["session_started"] = _speech_py_impl.DialogServiceConnector_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.DialogServiceConnector_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.DialogServiceConnector_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.DialogServiceConnector_session_stopped_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.DialogServiceConnector_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.DialogServiceConnector_canceled_get)
    __swig_getmethods__["activity_received"] = _speech_py_impl.DialogServiceConnector_activity_received_get
    if _newclass:
        activity_received = _swig_property(_speech_py_impl.DialogServiceConnector_activity_received_get)
    __swig_getmethods__["properties"] = _speech_py_impl.DialogServiceConnector_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.DialogServiceConnector_properties_get)

    def connect_async(self)  :
        return _speech_py_impl.DialogServiceConnector_connect_async(self)

    def disconnect_async(self)  :
        return _speech_py_impl.DialogServiceConnector_disconnect_async(self)

    def send_activity_async(self, activity )  :
        return _speech_py_impl.DialogServiceConnector_send_activity_async(self, activity)

    def listen_once_async(self)  :
        return _speech_py_impl.DialogServiceConnector_listen_once_async(self)

    def start_keyword_recognition_async(self, model )  :
        return _speech_py_impl.DialogServiceConnector_start_keyword_recognition_async(self, model)

    def stop_keyword_recognition_async(self)  :
        return _speech_py_impl.DialogServiceConnector_stop_keyword_recognition_async(self)
DialogServiceConnector_swigregister = _speech_py_impl.DialogServiceConnector_swigregister
DialogServiceConnector_swigregister(DialogServiceConnector)

def DialogServiceConnector_from_config(connector_config , audio_input =0)  :
    return _speech_py_impl.DialogServiceConnector_from_config(connector_config, audio_input)
DialogServiceConnector_from_config = _speech_py_impl.DialogServiceConnector_from_config

class Session(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Session, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Session, name)
    __repr__ = _swig_repr

    def __init__(self, hsession ):
        this = _speech_py_impl.new_Session(hsession)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Session
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.Session_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.Session_properties_get)
Session_swigregister = _speech_py_impl.Session_swigregister
Session_swigregister(Session)

class Connection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Connection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Connection, name)
    __repr__ = _swig_repr
    if _newclass:
        from_recognizer = staticmethod(_speech_py_impl.Connection_from_recognizer)
    else:
        from_recognizer = _speech_py_impl.Connection_from_recognizer

    def open(self, forContinuousRecognition )  :
        return _speech_py_impl.Connection_open(self, forContinuousRecognition)

    def close(self)  :
        return _speech_py_impl.Connection_close(self)

    def set_message_property(self, path , propertyName , propertyValue )  :
        return _speech_py_impl.Connection_set_message_property(self, path, propertyName, propertyValue)
    __swig_getmethods__["connected"] = _speech_py_impl.Connection_connected_get
    if _newclass:
        connected = _swig_property(_speech_py_impl.Connection_connected_get)
    __swig_getmethods__["disconnected"] = _speech_py_impl.Connection_disconnected_get
    if _newclass:
        disconnected = _swig_property(_speech_py_impl.Connection_disconnected_get)

    def __init__(self, handle ):
        this = _speech_py_impl.new_Connection(handle)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Connection
    __del__ = lambda self: None

    def send_message_async(self, path , payload )  :
        return _speech_py_impl.Connection_send_message_async(self, path, payload)
Connection_swigregister = _speech_py_impl.Connection_swigregister
Connection_swigregister(Connection)

def Connection_from_recognizer(recognizer )  :
    return _speech_py_impl.Connection_from_recognizer(recognizer)
Connection_from_recognizer = _speech_py_impl.Connection_from_recognizer

class Grammar(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Grammar, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Grammar, name)
    __repr__ = _swig_repr
    if _newclass:
        from_storage_id = staticmethod(_speech_py_impl.Grammar_from_storage_id)
    else:
        from_storage_id = _speech_py_impl.Grammar_from_storage_id

    def __init__(self, *args):
        this = _speech_py_impl.new_Grammar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Grammar
    __del__ = lambda self: None
Grammar_swigregister = _speech_py_impl.Grammar_swigregister
Grammar_swigregister(Grammar)

def Grammar_from_storage_id(storageId )  :
    return _speech_py_impl.Grammar_from_storage_id(storageId)
Grammar_from_storage_id = _speech_py_impl.Grammar_from_storage_id

class PhraseListGrammar(Grammar):
    __swig_setmethods__ = {}
    for _s in [Grammar]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhraseListGrammar, name, value)
    __swig_getmethods__ = {}
    for _s in [Grammar]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PhraseListGrammar, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _speech_py_impl.new_PhraseListGrammar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add_phrase(self, text )  :
        return _speech_py_impl.PhraseListGrammar_add_phrase(self, text)

    def clear(self)  :
        return _speech_py_impl.PhraseListGrammar_clear(self)
    if _newclass:
        from_recognizer = staticmethod(_speech_py_impl.PhraseListGrammar_from_recognizer)
    else:
        from_recognizer = _speech_py_impl.PhraseListGrammar_from_recognizer
    __swig_destroy__ = _speech_py_impl.delete_PhraseListGrammar
    __del__ = lambda self: None
PhraseListGrammar_swigregister = _speech_py_impl.PhraseListGrammar_swigregister
PhraseListGrammar_swigregister(PhraseListGrammar)

def PhraseListGrammar_from_recognizer(recognizer )  :
    return _speech_py_impl.PhraseListGrammar_from_recognizer(recognizer)
PhraseListGrammar_from_recognizer = _speech_py_impl.PhraseListGrammar_from_recognizer

class GrammarList(Grammar):
    __swig_setmethods__ = {}
    for _s in [Grammar]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrammarList, name, value)
    __swig_getmethods__ = {}
    for _s in [Grammar]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrammarList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _speech_py_impl.new_GrammarList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_GrammarList
    __del__ = lambda self: None
GrammarList_swigregister = _speech_py_impl.GrammarList_swigregister
GrammarList_swigregister(GrammarList)

class ClassLanguageModel(Grammar):
    __swig_setmethods__ = {}
    for _s in [Grammar]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassLanguageModel, name, value)
    __swig_getmethods__ = {}
    for _s in [Grammar]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassLanguageModel, name)
    __repr__ = _swig_repr
    if _newclass:
        from_storage_id = staticmethod(_speech_py_impl.ClassLanguageModel_from_storage_id)
    else:
        from_storage_id = _speech_py_impl.ClassLanguageModel_from_storage_id

    def __init__(self, *args):
        this = _speech_py_impl.new_ClassLanguageModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ClassLanguageModel
    __del__ = lambda self: None
ClassLanguageModel_swigregister = _speech_py_impl.ClassLanguageModel_swigregister
ClassLanguageModel_swigregister(ClassLanguageModel)

def ClassLanguageModel_from_storage_id(storageId )  :
    return _speech_py_impl.ClassLanguageModel_from_storage_id(storageId)
ClassLanguageModel_from_storage_id = _speech_py_impl.ClassLanguageModel_from_storage_id


from enum import Enum
def inject_enum(prefix ):
# get swig-generated enum values
    swig_enum_vars = {k: v for k, v in globals().items() if k.startswith(prefix + '_')}
    for k, v in swig_enum_vars.items():
        del globals()[k]
    new_enum_vars = {k[len(prefix) + 1: ]: v for k, v in swig_enum_vars.items()}
# create python enum and inject into module namespace
    globals()[prefix] = Enum(prefix, new_enum_vars)
    globals()[prefix].__doc__ = globals()['DocstringFor' + prefix]
    del globals()['DocstringFor' + prefix]

inject_enum('CancellationReason')
inject_enum('CancellationErrorCode')
inject_enum('NoMatchReason')
inject_enum('OutputFormat')
inject_enum('PropertyId')
inject_enum('ResultReason')
inject_enum('ServicePropertyChannel')
inject_enum('ProfanityOption')
inject_enum('StreamStatus')
inject_enum('SpeechSynthesisOutputFormat')

# clean up the exported names
del inject_enum
del Enum


swigregister_class_names = [variable_name for variable_name in globals() if variable_name.endswith('_swigregister')]
from_factory_method_names = [variable_name for variable_name in globals() if '__from' in variable_name.lower()]
for variable_name in swigregister_class_names + from_factory_method_names:
    del globals()[variable_name]

del from_factory_method_names, swigregister_class_names, variable_name

# This file is compatible with both classic and new-style classes.


